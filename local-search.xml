<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go  控制反转和依赖注入</title>
    <link href="/2022/08/06/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    <url>/2022/08/06/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="当前问题"><a href="#当前问题" class="headerlink" title="当前问题"></a>当前问题</h2><ul><li>当模块A依赖B，模块B依赖C，模块C依赖D，模块D依赖模块A时，GO编译就会报错 <em>import cycle not allowed</em> （循环依赖）</li></ul><p><img src="/img/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/ioc.png" alt="ioc"></p><ul><li>多个模块就像多个齿轮一样共同协作完成任务，但是也可能会出现一个齿轮出现问题将会影响到整个齿轮组的运转的情况</li><li>真实的服务可能需要依赖很多其他的服务，比如第三方，内部模块或者其他内部服务，当多个模块相互依赖增多时，也会增加项目的耦合，不利于后续功能拓展</li></ul><p><img src="/img/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/object-dep.png" alt="object-dep"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>控制反转</p></blockquote><p>控制反转（<code>Inversion of Control</code>）（<code>IOC</code>）是一种是面向对象编程中的一种设计原则，用来<strong>降低计算机代码之间的耦合度</strong>。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦</p><p><img src="/img/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/e2ce8ff5633d22eb11021febe7f61e93.jpeg" alt="e2ce8ff5633d22eb11021febe7f61e93"></p><p>由于引进了中间位置的“第三方”，也就是<code>IOC</code>容器，使得A、B、C、D这4个对象没有了耦合关系，<strong>将控制权都交给了<code>IOC</code>，齿轮之间的转动全部依靠“第三方”</strong>，对象A获得依赖对象B的过程,由主动行为变为了被动行为，<strong>控制权颠倒过来了</strong>，这就是“控制反转”这个名称的由来</p><p>对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度</p><p>​    </p><blockquote><p>依赖注入</p></blockquote><p>假设原本A依赖B，现在<code>IOC</code>需要<code>new</code>一个B出来，然后把B的实例注入到A里面去，这样A就可以正常使用基于B的方法了，这个过程被称为依赖项注入，而基于<code>IOC</code>的这种方法就叫做依赖注入</p><p>“<strong>获得依赖对象的过程被反转了</strong>”。控制被反转之后，获得依赖对象的过程由自身管理变为了由<code>IOC</code>容器主动注入</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><blockquote><p>当前场景</p></blockquote><p>目前有一个创建文章<code>Article</code>的接口，分别做了http接口和gRPC接口。为了避免代码冗余，现在将具体逻辑放在gRPC中实现，而http接口将会调用gRPC函数来实现对应功能，而gRPC方法的调用需要创建相应的实例才能调用，下面是改造前的代码</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /apps/artcicle/http/http.go http接口</span><br><span class="hljs-keyword">var</span> service *Handler<br><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">struct</span> &#123;<br>svc article.Service <span class="hljs-comment">//实现gRPC中article相关方法的接口</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span> &#123;<br>  ......<br>   <br>  service = NewArtcileService() <span class="hljs-comment">//在创建router前初始化gRPC实例并传进每一个接口中</span><br>  r := NewRouter(service)<br>  <br>  ......<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRouter</span><span class="hljs-params">(s *ArticleService)</span></span>&#123;<br>  r := gin.Default()<br>  r.POST(<span class="hljs-string">&quot;/article&quot;</span> ,s.createArticle) <span class="hljs-comment">//传入gRPC实例</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时可以看出在http包中，创建router前，初始化了gRPC调用的实例，并将此实例传进了http具体的业务函数中，从而实现能在http接口中使用gRPC的函数，<strong>减少代码冗余的同时增加了http模块对gRPC模块的依赖</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /apps/artcicle/http/article.go http接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Handler)</span> <span class="hljs-title">createArticle</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>......<br><br>rsp, err := h.svc.CreateArticle(c.Request.Context(), req) <span class="hljs-comment">//调用gRPC方法</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>response.Failed(ßerr)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>......<br>&#125;<br><br><span class="hljs-comment">// /apps/article/grpc/article.go grpc接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *ArticleService)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, req *artcile.Article)</span> <span class="hljs-params">(*article.Article, error)</span></span> &#123;<br>......<br>  <br><span class="hljs-keyword">if</span> err := a.dao.save(ctx, article); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> article, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>引入IOC</p></blockquote><p>下面是使用控制反转和依赖注入的模式后的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /apps/ioc.go</span><br><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;xxx/apps/article/grpc&quot;</span> <span class="hljs-comment">// 引入gRPC包，目的是为了使用其中的init方法为ioc容器中new一个article的grpc实例</span><br><br><span class="hljs-keyword">var</span> ArticleService Article.Service <span class="hljs-comment">//实现gRPC中article相关方法的接口</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">()</span></span> &#123; <br>  ...... <span class="hljs-comment">//省略的逻辑：为http的Handler创建包含Config()的接口，然后在ioc中会有函数去将各个调用模块创建的接口会存进map ginApps中</span><br>  <br>  <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> ginApps &#123;<br>v.Config() <span class="hljs-comment">//主动将gRPC实例注入到调用模块中</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// /apps/article/grpc/grpc.go grpc接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>  ioc.ArticleService = NewArticleService() <span class="hljs-comment">// 为ioc容器中new一个grpc实例，则后续可以将该实例注入到其他模块中，就可以在其他模块中使用本模块的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// apps/artcicle/http/http.go http接口</span><br><span class="hljs-keyword">var</span> service *Handler<br><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">struct</span> &#123;<br>svc article.Service <span class="hljs-comment">//实现gRPC中article相关方法的接口</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Handler)</span> <span class="hljs-title">Conifg</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//该方法被ioc容器调用</span><br>  h.svc = apps.ArticleService <span class="hljs-comment">//ioc中出初始化的gRPC实例注入到http模块中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面改进后的代码可以看出，之前的逻辑是是http模块依赖gRPC模块，使用<code>IOC</code>容器后，逻辑就变成了<code>IOC</code>容器初始化gRPC模块的实例，然后再将该实例注入到http模块中，解除了http模块和gRPC模块之间的耦合</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>使用控制反转和依赖注入可以减少项目的耦合度，有利于后续功能的拓展</p></li><li><p>项目中由于引入了第三方<code>IOC</code>容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，现在又凭空多出一道手续，会使得项目变得不太直观</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gomock</title>
    <link href="/2022/05/04/Go_Mock/"/>
    <url>/2022/05/04/Go_Mock/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是gomock"><a href="#什么是gomock" class="headerlink" title="什么是gomock"></a>什么是gomock</h1><p>gomock是Go官方提供的<strong>mock框架</strong>，提供打桩stub和验证调用的功能，它能对代码中的<strong>接口类型</strong>进行mock，方便编写<strong>单元测试</strong></p><p>mockgen工具用于针对<strong>接口</strong>生成mock对象代码（不能mock单独的函数或方法，必须是接口）</p><p>gomock通过<code>mockgen</code>命令生成包含mock对象的 .go 文件，生成的mock对象<strong>具备mock+stub</strong>的强大功能</p><h1 id="安装和使用mockgen"><a href="#安装和使用mockgen" class="headerlink" title="安装和使用mockgen"></a>安装和使用mockgen</h1><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/golang/mock/gomock<br><span class="hljs-keyword">go</span> insatll github.com/golang/mock/mockgen<br><span class="hljs-comment">//安装完成后可以在命令行中直接使用mockgen命令（需要将$GOPATH/bin添加到PATH环境变量）</span><br></code></pre></td></tr></table></figure><p>​    </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">mockgen -<span class="hljs-keyword">source</span> xxx.<span class="hljs-keyword">go</span> [<span class="hljs-keyword">options</span>]<br></code></pre></td></tr></table></figure><p><img src="/img/Go_Mock/image-20220504111610258.png" alt="image-20220504111610258"></p><blockquote><p>flags</p></blockquote><ul><li><p><code>-source</code>：包含要mock的接口的文件</p></li><li><p><code>-destination</code>：生成的源代码写入的文件。如果不设置此项，代码将打印到标准输出</p></li><li><p><code>-package</code>：用于生成的模拟类源代码的包名。如果不设置此项包名默认在原包名前添加<code>mock_</code>前缀</p></li></ul><h1 id="mock和stub"><a href="#mock和stub" class="headerlink" title="mock和stub"></a>mock和stub</h1><p>下面使用日常开发的案例进行演示，如博客项目中对文章数据表进行增删改查</p><blockquote><p>想要测试的函数</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdateArticle</span><span class="hljs-params">(c *gin.Context, db dao.ArticleDao, req UpdateArticleREQ)</span> <span class="hljs-title">error</span></span> &#123;<br>article := model.Article&#123;<br>BaseModel: model.BaseModel&#123;<br>ID: req.ID,<br>&#125;,<br>Title:   req.Title,<br>Content: req.Content,<br>Desc:    req.Desc,<br>&#125;<br><span class="hljs-keyword">if</span> err := db.Update(article); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//这一步是需要连接数据库进行相关文章的更新，但是在单元测试时不想连接数据库，则需要进行打桩stub</span><br>log.Errorf(<span class="hljs-string">&quot;save article err %v&quot;</span>, err)<br>common.ResErrCode(c, common.ErrService)<br><span class="hljs-keyword">return</span> err<br>&#125;<br>log.Infof(<span class="hljs-string">&quot;update article %s success&quot;</span>, article.Title)<br>common.ResSuccessMsg(c)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>首先使用文章数据表的数据库操作接口</p></blockquote><p>因为mock是接口类型的测试框架，所以需要构造测试单元函数的相应接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ArticleDao <span class="hljs-keyword">interface</span> &#123;<br>Get(id <span class="hljs-keyword">uint</span>) (model.Article, error)<br>List(opt common.ListOption) ([]model.Article, error)<br>Create(article model.Article) error<br>Update(article model.Article) error<br>Delete(article model.Article) error<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>使用mockgen工具生成相应的mock代码</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">mockgen -<span class="hljs-keyword">source</span> article.<span class="hljs-keyword">go</span> -destination mock/mock_article.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>生成的代码不需要对它们进行编辑，只需要在单元测试时调用它们</p><p>​    </p><blockquote><p>单元测试</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestArticle_Update</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>  <span class="hljs-comment">//创建gomock控制器，用来记录后续的操作信息</span><br>ctrl := gomock.NewController(t)<br><span class="hljs-keyword">defer</span> ctrl.Finish()<br><br>  <span class="hljs-comment">//调用mockgen生成代码中的NewMockArticleDao()方法</span><br>mockDao := mocks.NewMockArticleDao(ctrl)<br>  <span class="hljs-comment">//打桩(stub)</span><br>mockDao.EXPECT().Update(gomock.Any()).Return(<span class="hljs-literal">nil</span>)<br><br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>ctx *gin.Context<br>db  dao.ArticleDao<br>req UpdateArticleREQ<br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">//表格驱动测试方法(Table Driven Tests)</span><br>name <span class="hljs-keyword">string</span><br>args args<br>want error<br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;default&quot;</span>,<br>args: args&#123;<br>ctx: &amp;gin.Context&#123;&#125;,<br>db:  mockDao, <span class="hljs-comment">//注入mockDao</span><br>req: UpdateArticleREQ&#123;<br>ID:      <span class="hljs-number">1</span>,<br>Title:   <span class="hljs-string">&quot;test&quot;</span>,<br>Content: <span class="hljs-string">&quot;this is test&quot;</span>,<br>&#125;,<br>&#125;,<br>want: <span class="hljs-literal">nil</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(test.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>err := UpdateArticle(test.args.ctx, test.args.db, test.args.req)<span class="hljs-comment">//单元测试时将mockDao传入替换相应接口</span><br><span class="hljs-keyword">if</span> !reflect.DeepEqual(err, test.want) &#123;<br>t.Errorf(<span class="hljs-string">&quot;UpdateArticle() = %v, want %v&quot;</span>, err, test.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>打桩（stub）</p></blockquote><p>软件测试中的打桩是指用一些代码（桩stub）<strong>代替目标代码</strong>，通常用来<strong>屏蔽或补齐业务逻辑中的关键代码</strong>方便进行单元测试。</p><ul><li><p><strong>屏蔽</strong>：不想在单元测试用引入数据库连接等重资源</p></li><li><p><strong>补齐</strong>：依赖的上下游函数或方法还未实现</p></li></ul><p>​    </p><p>上面的单元测试中引入打桩代码，目的是为了在测试 UpdateArticle( ) 中不想连接数据库并进行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">mockDao.EXPECT().Update(gomock.Any()).Return(<span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><p>结合最开始文章表相关数据库操作接口，<strong>表示在测试 UpdateArticle( ) 时如果遇到 <code>Update(article model.Article) error</code> 的函数，无论传入任何参数 (<code>gomock.Any()</code>) 都返回<code>nil</code> (<code>Return(nil)</code>)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ArticleDao <span class="hljs-keyword">interface</span> &#123;<br>Update(article model.Article) error<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mockDao.EXPECT().Update(gomock.Any()).Return(<span class="hljs-literal">nil</span>)<br>mockDao.EXPECT().Update(gomock.Not(value)).Return(<span class="hljs-literal">nil</span>)<br>mockDao.EXPECT().Update(gomock.Nil()).Return(<span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><ul><li><p><code>gomock.Any( )</code>：任意参数</p></li><li><p><code>gomock.Not(value)</code>：非value的参数</p></li><li><p><code>gomock.Nil( )</code>：空值的参数</p></li><li><p><code>gomock.Eq(value)</code>：等于value的参数</p></li></ul><p><strong>返回值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">mockDao.EXPECT().Update(gomock.Any()).DoAndReturn(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span><span class="hljs-params">(error)</span></span> &#123;<br>t.Logf(<span class="hljs-string">&quot;input key is %v\n&quot;</span>, key)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><code>Return( )</code>：返回指定值</li><li><code>Do(func)</code>：执行操作，忽略返回值</li><li><code>DoAndReturn(func)</code>：执行并返回指定值</li></ul><p><strong>调用次数</strong></p><p>使用gomock工具mock的方法都会有期望被调用的次数，<strong>默认每个mock方法只允许被调用一次</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">mockDao.EXPECT().Update(gomock.Any()).Return(<span class="hljs-literal">nil</span>).Times(<span class="hljs-number">1</span>) <br></code></pre></td></tr></table></figure><ul><li><code>Times()</code> 指定mock方法被调用的次数</li><li><code>MaxTimes()</code> 最大次数</li><li><code>MinTimes()</code> 最小次数</li><li><code>AnyTimes()</code> 任意次数（包括 0 次）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法排序之快速、希尔、堆排序</title>
    <link href="/2022/02/17/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F&amp;%E5%B8%8C%E5%B0%94&amp;%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/02/17/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F&amp;%E5%B8%8C%E5%B0%94&amp;%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="快速排序法"><a href="#快速排序法" class="headerlink" title="快速排序法"></a>快速排序法</h2><ul><li><strong>思想是每次选取一个数，将它移动到数组之间，使其左边全部都是比它小的数，它的右边都是比它大的数</strong></li><li>数组中选取一个数，与左边第一个数进行交换，从第二个数开始逐步排序(<strong>比它大的位置就不动，比它小的就换到前面，这样大的数也就自动的移动到了后面</strong>)，<strong>最后在将第一个数与比它小的最后一个数进行交换使其移动到数组中间</strong>，使得左边的数都小于它，右边的数都大于它</li></ul><p>​    </p><blockquote><p><strong>存在问题</strong></p></blockquote><p>对于选取的数是左边第二个，如果是<strong>完全有序</strong>的数组，则每次递归左边都是nil，右边是比原先数组少一个元素的数组，即会递归n次<br>此时时间复杂度为<strong>n²</strong>，而<strong>栈的深度</strong>也会为n，会导致<strong>栈溢出</strong>的情况</p><p>​    </p><p><strong>解决方法</strong></p><ul><li>在<strong>partition</strong>时选取[l,r]之间的<strong>随机数</strong>，防止是有序数组而导致算法<strong>性能退化</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortQuick</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   QuickSort(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> l &gt;= r &#123;<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   p := partition(arr, l, r)<br>   QuickSort(arr, l, p<span class="hljs-number">-1</span>)<br>   QuickSort(arr, p+<span class="hljs-number">1</span>, r)<br>&#125;<br><br><span class="hljs-comment">//就是使[l+1,j]&lt;v,[j+1,i]&gt;v</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-comment">//生成[l,r]之间的随机索引，防止是有序数组而导致算法性能退化</span><br>   rand.Seed(time.Now().UnixNano()) <br>   v := rand.Intn(r-l+<span class="hljs-number">1</span>) + l<br>   arr[v], arr[l] = arr[l], arr[v] <span class="hljs-comment">//将其随机的数作为数组的一个元素</span><br><br>   j := l <span class="hljs-comment">//指向比v小的最后一个元素</span><br>   <span class="hljs-keyword">for</span> i := l + <span class="hljs-number">1</span>; i &lt;= r; i++ &#123;<br>      <span class="hljs-keyword">if</span> arr[i] &lt; arr[l] &#123;<br>         j++                             <span class="hljs-comment">//加了1后指向比v大的第一个元素</span><br>         arr[i], arr[j] = arr[j], arr[i] <span class="hljs-comment">//等于将这个数插入到比v小的数组的到最后一个</span><br>      &#125;<br>   &#125;<br>   arr[l], arr[j] = arr[j], arr[l] <span class="hljs-comment">//因为j是指向比v小的最后一个元素，这次交换将v变成了左边都比v小右边都比v大</span><br>   <span class="hljs-keyword">return</span> j<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双路快速排序法"><a href="#双路快速排序法" class="headerlink" title="双路快速排序法"></a>双路快速排序法</h3><blockquote><p>存在问题</p></blockquote><p>即使加入了随机数，但是在一个所有<strong>数相等</strong>的数组中，快速排序法还是<strong>退化</strong>成了<strong>n²</strong>的复杂度</p><p>​    </p><p><strong>解决思路</strong></p><ul><li>使用双路快速排序法 目的是将数组元素尽可能的<strong>分散在标定元素两侧</strong><br>目的是使得  <strong>arr[l+1,i-1]&lt;=v**   **arr[j+1,r]&gt;=v</strong></li></ul><p><img src="/img/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F&%E5%B8%8C%E5%B0%94&%E5%A0%86%E6%8E%92%E5%BA%8F/image-20210319192152777.png" alt="image-20210319192152777"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//快速排序法还是存在问题，即如果对于完全相同的一组数，还是会将其分成一边为空一边少一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition2</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-comment">//生成[l,r]之间的随机索引，防止是有序数组而导致算法性能退化</span><br>   rand.Seed(time.Now().UnixNano()) <br>   v := rand.Intn(r-l+<span class="hljs-number">1</span>) + l<br>   arr[v], arr[l] = arr[l], arr[v] <span class="hljs-comment">//将其随机的数作为数组的一个元素</span><br><br>   <span class="hljs-comment">//arr[l+1,i-1]&lt;=v arr[j+1,r]&gt;=v</span><br>   i := l + <span class="hljs-number">1</span><br>   j := r<br>   <span class="hljs-keyword">for</span> ; ; &#123;<br>      <span class="hljs-keyword">for</span> ; i &lt;= j &amp;&amp; arr[i] &lt; arr[l]; &#123;<br>         i++<br>      &#125;<br>      <span class="hljs-keyword">for</span> ; i &lt;= j &amp;&amp; arr[j] &gt; arr[l]; &#123;<br>         j--<br>      &#125;<br>      <span class="hljs-keyword">if</span> i &gt;= j &#123;<br>         <span class="hljs-keyword">break</span><br>      &#125;<br>      <span class="hljs-comment">//当i遇到比l大的元素就停下，j遇上比l小的元素就停下，进行交换，使得arr[l+1,i-1]&lt;=v arr[j+1,r]&gt;=v</span><br>      arr[i], arr[j] = arr[j], arr[i]<br>      i++<br>      j--<br>   &#125;<br>   arr[l], arr[j] = arr[j], arr[l] <span class="hljs-comment">//此时只能用j替换和返回而不能是i，因为如果当i和j进到相同位置时此而时该数又比v小则会出错（将大的数交换到l位置了）</span><br>   <span class="hljs-keyword">return</span> j<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a><strong>复杂度</strong></h4><p>由于加入了<strong>随机数</strong>和双路排序思想，则<strong>不能</strong>找到一个<strong>100%恶化的数组</strong></p><p>则此时双路快速排序法是一个<strong>随机算法</strong>，不能采用最差情况讨论复杂度，而是要看<strong>期望</strong></p><p>其期望还是 <strong>nlogn</strong> 的复杂度</p><h3 id="三路快速排序法"><a href="#三路快速排序法" class="headerlink" title="三路快速排序法"></a>三路快速排序法</h3><blockquote><p>存在问题</p></blockquote><p>在二路快排中，虽然相同元素的数组中的元素被均摊到了两边，但是可以<strong>不必要</strong>再对<strong>相同元素</strong>再进行排序</p><p>​    </p><p><strong>解决思路</strong></p><ul><li>对于元素一样的数组，其复杂度为 <strong>n</strong></li></ul><p>​       目的是使得  <strong>arr[l+1,lt]&lt;v**   **arr[lt+1,i-1]=v**   **arr[gt,r]&gt;v</strong></p><p><img src="/img/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F&%E5%B8%8C%E5%B0%94&%E5%A0%86%E6%8E%92%E5%BA%8F/image-20210319192236771.png" alt="image-20210319192236771"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort3way</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> l &gt;= r &#123;<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   v := rand.Intn(r-l+<span class="hljs-number">1</span>) + l<br>   arr[v], arr[l] = arr[l], arr[v]<br>   <span class="hljs-comment">//arr[l+1,lt]&lt;v arr[lt+1,i-1]=v arr[gt,r]&gt;v</span><br>   <span class="hljs-comment">//lt指向小于v的最后一个元素，gt指向大于v的第一个元素</span><br>   lt := l<br>   i := l + <span class="hljs-number">1</span><br>   gt := r + <span class="hljs-number">1</span><br>   <span class="hljs-keyword">for</span> ; i &lt; gt; &#123;<br>      <span class="hljs-keyword">if</span> arr[i] &lt; arr[l] &#123;<br>         lt++<br>         arr[lt], arr[i] = arr[i], arr[lt]<br>         i++<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> arr[i] &gt; arr[l] &#123;<br>         gt--<br>         arr[gt], arr[i] = arr[i], arr[gt] <span class="hljs-comment">//此时不用i++，因为此时来了一个新的元素arr[gt]，这个元素还没有比较</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         i++<br>      &#125;<br>   &#125;<br>   arr[l], arr[lt] = arr[lt], arr[l]<br>   <span class="hljs-comment">//arr[l,lt-1]&lt;v arr[lt,gt-1]==v arr[gt,r]&gt;v</span><br>   QuickSort3way(arr, l, lt<span class="hljs-number">-1</span>)<br>   QuickSort3way(arr, gt, r)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序法"><a href="#堆排序法" class="headerlink" title="堆排序法"></a>堆排序法</h2><p>将数组中的数加入堆复杂度是 <strong>nlogn</strong></p><p>将堆中依次 <strong>ExtractMax</strong> 复杂度是 <strong>nlogn</strong></p><p>总复杂度是 <strong>2nlogn</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   h := heap.NewMaxHeap(<span class="hljs-built_in">len</span>(arr))<br>   <span class="hljs-comment">//nlogn</span><br>   <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>      h.Add(v)<br>   &#125;<br>   <span class="hljs-comment">//nlogn</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>      arr[i] = h.ExtractMax()<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//取出元素 取出最大的元素 就是删除头结点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span> <span class="hljs-title">ExtractMax</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>res := h.FindMax()<br><span class="hljs-comment">//将尾结点和头结点交换，再删除尾结点，相当于删除了头结点</span><br>h.Array.Swap(<span class="hljs-number">0</span>, h.Array.Length<span class="hljs-number">-1</span>)<br>h.Array.RemoveLast()<br><span class="hljs-comment">//但是此时不满足完全二叉树的性质，需要进一步整理</span><br>h.shiftDown(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">//从头结点就是，找出自己左右孩子中最大的值，如果自己比它小，则进行交换</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span> <span class="hljs-title">shiftDown</span><span class="hljs-params">(k <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> leftChild(k) &lt; h.Array.GetSize() &#123; <span class="hljs-comment">//判断左孩子是否存在</span><br>j := leftChild(k)<br><span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span> &lt; h.Array.GetSize() &amp;&amp; h.Array.Get(j) &lt; h.Array.Get(j+<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//j+1就是右孩子</span><br>j = rightChild(k)<br>&#125;<br><span class="hljs-comment">//此时data[j]就是左右孩子中最大的值</span><br><span class="hljs-keyword">if</span> h.Array.Get(j) &lt;= h.Array.Get(k) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>h.Array.Swap(k, j)<br>k = j<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h3><p>通过<strong>Heapify</strong>将数组<strong>堆化</strong>，其<strong>时间复杂度</strong>是 <strong>n</strong></p><p>没有开辟额外空间，<strong>空间复杂度</strong>是 <strong>1</strong></p><p>思路是：</p><ul><li>将堆化的数组第一个元素和最后一个元素<strong>进行交换</strong>，使得最后一个元素排序成功</li><li>此时前n-1个元素又不满足最大堆，则通过<strong>特殊的shiftDown</strong>将前n-1个元素排序成堆</li><li>此时再将第一个元素和倒数第二个元素进行交换，直至排序成功</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapSort2</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span> &#123;<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   heap.Heapify(arr)<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>      arr[<span class="hljs-number">0</span>], arr[i] = arr[i], arr[<span class="hljs-number">0</span>]<br>      shiftDownArr(arr, <span class="hljs-number">0</span>, i)<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//将任意数组转化成成堆形式</span><br><span class="hljs-comment">//只需拿到最后一个非叶子结点，依次向前shiftDown (抛弃掉了所有叶子结点，相当于少了一半)</span><br><span class="hljs-comment">//最后一个非叶子结点只需要最后一个结点再求它的parent</span><br><span class="hljs-comment">//其复杂度是n</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Heapify</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>h := MaxHeap&#123;*array.NewInArray(arr, <span class="hljs-built_in">len</span>(arr))&#125;<br><span class="hljs-keyword">for</span> i := parent(<span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>h.shiftDown(i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shiftDownArr</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, k, n <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> <span class="hljs-number">2</span>*k+<span class="hljs-number">1</span> &lt; n &#123;<br>      j := <span class="hljs-number">2</span>*k + <span class="hljs-number">1</span> <span class="hljs-comment">//左孩子索引</span><br>      <span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span> &lt; n &amp;&amp; arr[j] &lt; arr[j+<span class="hljs-number">1</span>] &#123;<br>         j++ <span class="hljs-comment">//j等于右孩子索引</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> arr[j] &lt;= arr[k] &#123;<br>         <span class="hljs-keyword">break</span><br>      &#125;<br>      arr[k], arr[j] = arr[j], arr[k]<br>      k = j<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="希尔排序法"><a href="#希尔排序法" class="headerlink" title="希尔排序法"></a>希尔排序法</h2><ul><li>基本思想：让数组<strong>越来越有序</strong>，<strong>不能</strong>只处理<strong>相邻逆序对</strong></li></ul><p>对元素间距为<strong>n/2</strong>的所有数组做<strong>插入排序</strong>，对元素间距为<strong>n/4</strong>的所有数组做<strong>插入排序</strong>， …  对元素间距为<strong>1</strong>进行<strong>插入排序</strong></p><p>看上去有四重循环，实际上其因为数组会越来越有序，循环n的次数也会越来越少，其复杂度是<strong>大于nlogn而小于n²</strong>，在数组小的时候其性能可能还会超越nlogn<br><strong>并且没有使用递归，仅依靠循环就完成了排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>h := <span class="hljs-built_in">len</span>(arr) / <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> h &gt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">for</span> start := <span class="hljs-number">0</span>; start &lt; h; start++ &#123;<br><span class="hljs-comment">//对data[start,start+h,start+2h...]进行插入排序</span><br><span class="hljs-keyword">for</span> i := start + h; i &lt; <span class="hljs-built_in">len</span>(arr); i += h &#123;<br><span class="hljs-comment">//使用插入排序法</span><br><span class="hljs-keyword">for</span> j := i; j-h &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &lt; arr[j-h]; j -= h &#123;<br>arr[j], arr[j-h] = arr[j-h], arr[j]<br>&#125;<br>&#125;<br>&#125;<br>h /= <span class="hljs-number">2</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>四重循环压缩成三重循环，但是复杂度并<strong>没有改变</strong><br>不用分别对<strong>分开</strong>的数组对分别使用插入排序,可以直接<strong>交替</strong>对数组对使用插入排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ShellSort2</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>h := <span class="hljs-built_in">len</span>(arr) / <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> h &gt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">//对data[h...]进行插入排序</span><br><span class="hljs-keyword">for</span> i := h; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br><span class="hljs-comment">//使用插入排序法</span><br><span class="hljs-keyword">for</span> j := i; j-h &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &lt; arr[j-h]; j -= h &#123;<br>arr[j], arr[j-h] = arr[j-h], arr[j]<br>&#125;<br>&#125;<br>h /= <span class="hljs-number">2</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="步长序列"><a href="#步长序列" class="headerlink" title="步长序列"></a>步长序列</h3><p>步长序列<strong>不同</strong>，<strong>复杂度分析不同</strong>，因为步长序列是一个<strong>超参数</strong></p><p>还没有证明出一个最好的步长序列使得希尔排序性能最好</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ShellSort3</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>h := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> h &lt; <span class="hljs-built_in">len</span>(arr) &#123;<br>h = <span class="hljs-number">3</span>*h + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">for</span> h &gt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">//对data[h...]进行插入排序</span><br><span class="hljs-keyword">for</span> i := h; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br><span class="hljs-comment">//使用插入排序法</span><br><span class="hljs-keyword">for</span> j := i; j-h &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &lt; arr[j-h]; j -= h &#123;<br>arr[j], arr[j-h] = arr[j-h], arr[j]<br>&#125;<br>&#125;<br>h /= <span class="hljs-number">3</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基于比较的排序算法总结"><a href="#基于比较的排序算法总结" class="headerlink" title="基于比较的排序算法总结"></a>基于比较的排序算法总结</h2><h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p><img src="/img/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F&%E5%B8%8C%E5%B0%94&%E5%A0%86%E6%8E%92%E5%BA%8F/image-20210329114121325.png" alt="image-20210329114121325"></p><p>快速排序法是一个<strong>随机算法</strong>，则时间复杂度要用<strong>期望</strong></p><p>​    </p><p><img src="/img/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F&%E5%B8%8C%E5%B0%94&%E5%A0%86%E6%8E%92%E5%BA%8F/image-20210329114302831.png" alt="image-20210329114302831"></p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>如果元素只有一个域，稳定性没有意义</p><p><img src="/img/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F&%E5%B8%8C%E5%B0%94&%E5%A0%86%E6%8E%92%E5%BA%8F/image-20210329114839253.png" alt="image-20210329114839253"></p><p>​    </p><p><strong>基础排序算法的稳定性</strong></p><p>插入排序法中相同的元素<strong>没有机会</strong>进行 “<strong>跳跃</strong>“</p><p><img src="/img/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F&%E5%B8%8C%E5%B0%94&%E5%A0%86%E6%8E%92%E5%BA%8F/image-20210329124619316.png" alt="image-20210329124619316"></p><p>​    </p><p><strong>高级排序算法的稳定性</strong></p><p><img src="/img/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F&%E5%B8%8C%E5%B0%94&%E5%A0%86%E6%8E%92%E5%BA%8F/image-20210329125243456.png" alt="image-20210329125243456"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Goroutine原理</title>
    <link href="/2022/02/12/GO_Goroutine%E5%8E%9F%E7%90%86/"/>
    <url>/2022/02/12/GO_Goroutine%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><ul><li>进程：资源分配的基本单位</li><li>线程：调度的基本单位</li><li>无论是在线程还是进程，在Linux都是task_struct描述，从内核角度来看，与进程无本质区别</li></ul><p><img src="/img/GO_Goroutine%E5%8E%9F%E7%90%86/image-20220207154421068.png" alt="image-20220207154421068"></p><p><strong>Liunx中创建线程就相当于是创建进程，只不过内存、文件等信息进行共享</strong></p><p>​    </p><blockquote><p>Linux进程的内存使用</p></blockquote><p><img src="/img/GO_Goroutine%E5%8E%9F%E7%90%86/image-20220207160101624.png" alt="image-20220207160101624"></p><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino">size file_name <span class="hljs-comment">//查看目标文件的内存使用情况</span><br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>为何栈向下生长，堆向上生长</p></blockquote><p>每一个可执行可编译程序，从低地址到高地址依次是：text、data、bss、堆、栈、环境参数变量；其中堆和栈之间有很大的地址空间空闲着，在需要分配空间的时候，堆向上涨，栈往下涨</p><p>这样设计可以使得堆和栈能够充分利用空闲的地址空间，一个向上涨，一个向下涨，这样它们就可以<strong>最大程度地共用这块剩余的地址空间，达到利用率的最大化</strong></p><p>​    </p><blockquote><p>CPU对内存的访问</p></blockquote><p><img src="/img/GO_Goroutine%E5%8E%9F%E7%90%86/image-20220207162324065.png" alt="image-20220207162324065"></p><p>这样就进行的内存交换（通过查页表找映射关系），将磁盘上的虚拟内存交换到物理内存上</p><h3 id="进程和线程切换的区别"><a href="#进程和线程切换的区别" class="headerlink" title="进程和线程切换的区别"></a>进程和线程切换的区别</h3><blockquote><p>进程切换开销</p></blockquote><ul><li>直接开销<ul><li>切换页表全局目录（PGD）</li><li>切换内核态堆栈</li><li>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</li><li>刷新 TLB</li><li>系统调度器的代码执行</li></ul></li><li>间接开销<ul><li>CPU 缓存失效导致的进程需要到内存直接访问的 IO 操作变多</li></ul></li></ul><p>​    </p><blockquote><p>线程切换开销</p></blockquote><ul><li>线程本质上只是一批共享资源的进程，线程切换本质上依然需要内核进行进程切换</li><li>一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间，线程切换相比进程切换，<strong>主要节省了虚拟地址空间的切换</strong></li></ul><p>​    </p><blockquote><p><strong>用户线程</strong></p></blockquote><p><strong>无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成</strong></p><p><img src="/img/GO_Goroutine%E5%8E%9F%E7%90%86/image-20220207163522414.png" alt="image-20220207163522414"></p><p>在程序的层面一次执行，<strong>无需通过系统调用的方式进行切换</strong>，一旦拿到时间片就尽可能的使用，减少对系统调用的依赖</p><h2 id="Goroutine原理"><a href="#Goroutine原理" class="headerlink" title="Goroutine原理"></a>Goroutine原理</h2><p><strong>Go 语言基于 GMP 模型实现用户态线程</strong></p><h3 id="goroutine和线程的区别"><a href="#goroutine和线程的区别" class="headerlink" title="goroutine和线程的区别"></a><strong>goroutine和线程的区别</strong></h3><ul><li><p><strong>内存占用</strong></p><p>创建一个<strong>goroutine</strong>的栈内存消耗为<strong>2KB</strong>，运行过程中，如果栈空间不够，会<strong>自动扩容</strong></p><p>创建一个<strong>thread</strong>为了避免极端情况下操作系统线程栈的溢出，默认会为其分配一个较大的栈内存(<strong>1-8MB</strong>),而且还需要一个被称为“<strong>guard page</strong>”的区域用于和其他thread的<strong>栈空间进行隔离</strong>（防止线程1因为栈溢出后污染了相邻的线程2，因为地址空间是相连的）。而栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有益处的风险</p></li><li><p><strong>创建/销毁</strong></p><p><strong>线程</strong>创建和销毁都会有巨大的消耗，是<strong>内核级</strong>的交互，而进入内核所消耗的性能代价比较高，开销较大</p><p>goroutine是<strong>用户态</strong>线程，是由goroutine管理，创建和销毁的消耗非常小</p></li></ul><p>​        <a href="https://blog.csdn.net/youngyoungla/article/details/53106671?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">用户态和内核态</a></p><ul><li><p><strong>调度切换</strong></p><p>​    抛开陷入内核，线程切换会消耗1000-1500纳秒（<strong>上下文保存成本高</strong>，较多寄存器，公平性，复杂时间计算统计），一个纳秒平均可以执行12-18条指令</p><p>​    所以由于线程切换，执行指令的条数会减少12000-18000。goroutine的切换约为200ns（用户态，3个寄存器），相当于2400-3600条指令。因此，goroutine切换成本比thread小得多</p></li><li><p><strong>复杂性</strong></p><p>​    线程的创建和退出复杂,多个thread间通讯复杂（share memory）</p><p>​    不能大量创建线程，成本高，使用网络多路复用，存在大量callback。对于应用服务线程门槛高，例如需要做第三方库隔离，需要考虑引入线程池等</p></li></ul><h3 id="GMP调度模型"><a href="#GMP调度模型" class="headerlink" title="GMP调度模型"></a>GMP调度模型</h3><ul><li><p><strong>G</strong>：goroutine的缩写，每次go func( )都代表一个G，无限制</p><p>每个 goroutine 都有自己的栈空间， 定时器，初始化的栈空间在 2k 左右，空间会随着需求增长</p></li><li><p><strong>M</strong>：工作线程(OS thread)也被称为Machine，使用struct runtime.m，所有M是有线程栈的</p><p>抽象化代表内核线程，记录内核线程栈信息，当 goroutine 调度到线程时，使用该 goroutine 自己的栈信息</p></li><li><p><strong>P</strong>：“Processor” 代表调度器，负责调度 goroutine，维护一个本地 goroutine 队列，M 从 P 上获得 goroutine 并执行，同时还负责部分内存的管理</p><p>它代表了M所需要的上下文环境，也是处理用户级代码逻辑的处理器，它负责衔接M和G的调度上下文(<strong>相当于一个队列，不停的从里面捞G来执行</strong>)，将等待执行的G与M对接，当P有任务时需要创建或者唤醒一个M来执行它队列里的任务。所以P/M需要进行绑定，构成一个执行单元</p><p><img src="/img/GO_Goroutine%E5%8E%9F%E7%90%86/image-20220212151314201.png" alt="image-20220212151314201"></p></li></ul><p>​    </p><p>P决定了并行任务的数量，可通过 <code>runtime.GOMAXPROCS</code> 来设定。在GO1.5之后 <code>GOMAXPROCS</code> 被默认设置CPU数量，而之前则默认是1</p><p>其中<strong>G相当于是用户线程，M相当于是内核线程数量，是可以大于P的(上限10000)，建立的P(上限是256)是和CPU数量是对应的</strong></p><p>这样做的目的是M可能陷入系统调用，而系统调用可能是阻塞的，比如磁盘读取，这个时候CPU是空闲的，创建新的M与P关联，可以让更多的G被调度，充分利用CPU</p><p><img src="/img/GO_Goroutine%E5%8E%9F%E7%90%86/image-20210418211549894.png" alt="image-20210418211549894"></p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p><strong>Go的调度本质上就是一个生成—消费模型，将消息写入队列再从队列中取出消息</strong></p><blockquote><p>gouroutine生产端</p></blockquote><p>有三个队列，优先级最高的是<strong>runnext(只能存一个值的队列，最快)</strong></p><p>其次就是local queue(<strong>数组，限制了大小（256），本地用数组访问的快，局部性原理，新来的优先级一定比老的高</strong>) 和global queue(链表，无限扩张)</p><p>​    </p><p><em>每次启动一个goroutine就现将任务放入runnext，如果runnext满了就将runnext原来的task踢到local queue中(<strong>默认新进来的goroutine优先级最高，最先处理</strong>)，如果runnext和local queue都满了，就将原来runnext中的task和local queue中一半的task拿出来拼成一个链表存到global queue</em></p><p><img src="/img/GO_Goroutine%E5%8E%9F%E7%90%86/image-20210825111837265.png" alt="image-20210825111837265"></p><p>​    </p><blockquote><p>goroutine消费端</p></blockquote><p>M执行循环调度，必须与一个P绑定</p><p>在local中 (优先在runnext中拿) 执行<strong>60</strong>次(先去本地队列里捞，就可以<strong>减少使用全局队列的锁，提高吞吐量</strong>。再去全局队列里捞，因为用全局队列会上锁)，就要去global (要加锁) 中执行<strong>1</strong>次(最多拿本地队列一半长度的goroutine)，还是没有就<strong>work-stealing</strong> (去其他队列里拿任务，拿一半)，如果还是没有就进入休眠状态</p><h3 id="work-stealing"><a href="#work-stealing" class="headerlink" title="work-stealing"></a><strong>work-stealing</strong></h3><p>M绑定的P没有可执行的goroutine时它会去按照优先级去抢占任务</p><p>先<strong>1/61的时间</strong>去<strong>全局队列</strong>里找 (<strong>防止全局队列里饥饿</strong>)，然后去<strong>本地队列</strong>找，然后去<strong>其他M</strong>里找 (<strong>防止本地队列里饥饿</strong>)</p><p>找到任何一各任务，切换调用栈执行任务，再循环不断的获取任务，直到进入休眠</p><p>其核心思想就是<strong>避免饥饿</strong> (其他进程都有事做，自己没有事做)</p><p>​    </p><p>为了保证公平性，从<strong>随机位置上的P</strong>开始，而且<strong>遍历的顺序也随机化</strong>了（选择一个小于GOMAXPROCS，且和它<strong>互为质数</strong>的步长），保证遍历的顺序也随机化了</p><p>​    </p><blockquote><p><strong>Spining thread</strong></p></blockquote><p>线程自旋是相对于<strong>线程阻塞</strong>而言的，表象就是循环执行一个指定逻辑（就是上面提到的逻辑，目的是<strong>不停的寻找G</strong>）。这样做的问题显而易见，如果G迟迟不来，CPU会白白浪费性能在这无意义的计算上。但好处也很明显，降低了M的上下文切换成本(不断睡眠和唤醒是需要消耗成本的），<strong>提高了性能</strong></p><ul><li>M带P的找G执行</li><li>M不带P的找P挂载</li><li>G创建有没spiningM唤醒一个M</li></ul><p>Go的设计者倾向于高性能的并发表现选择了后者。当然前面也提到过，为了避免浪费过多的资源，自旋的线程数不会超过GOMAXPROCS，这是因为一个P在同一时刻只能绑定一个M，P的数量不会超过GOMAXPROCS，自然被绑定的M的数量也不会超过。对于未绑定的游离态的M，会进入休眠状态阻塞</p><p>​    </p><blockquote><p><strong>Syscall</strong></p></blockquote><p>Go有自己封装的<strong>syscall(系统调用）</strong>，也就是进入和退出syscall的时候执行entersyscall/exitsyscall，也只有封装了系统调用才有可能触发重新调度，它将改变P的状态为syscall</p><ul><li><p>系统监视器 (system  monitor)，称为sysmon，会定时扫描，在执行系统调用时，如果某个P的G执行超过了一个sysmon tick，就会脱离M</p></li><li><p>P和M脱离后目前在idle list中等待被绑定。而syscall结束后M按照如下规则执行直到满足其中一个条件</p><ul><li>尝试获取同一个P，恢复执行G</li><li>尝试获取idle list中空闲P</li><li>把G放回global queue，M放回idle list</li></ul></li></ul><p>​    </p><blockquote><p><strong>Sysmon</strong></p></blockquote><p><strong>Go1.4后的异步抢占</strong>，注册sigurg信号，通过sysmon检测，对M对应的线程(<strong>运行超过10ms</strong>)发送信号，触发注册的handler，它往当前G的PC中插入一条指令(调用某个方法)，<strong>暂停</strong>当前goroutine，在处理完handler，G恢复后，自己把自己推到global queue中</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go GC原理</title>
    <link href="/2022/02/08/Go_GC%E5%8E%9F%E7%90%86/"/>
    <url>/2022/02/08/Go_GC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Go内存分配"><a href="#Go内存分配" class="headerlink" title="Go内存分配"></a>Go内存分配</h2><p><img src="/img/Go_GC%E5%8E%9F%E7%90%86/image-20220208215830761.png" alt="image-20220208215830761"></p><ul><li><p>Go要使用内存时不是直接去系统取，而是分成了四步依次取，当后者内存不足时就向前一步申请内存</p></li><li><p>每个线程都有自己的初始内存空间<strong>mcache</strong>，这个内存空间只有<strong>当前线程才能访问</strong>，当Go需要内存时首先会从该空间中获取 (因为前面三步的空间都是多个线程可以访问，获取时会加锁，大大增加了获取内存的时间)</p></li><li><p>如果mcache中内存不够用再去<strong>mcentral</strong>(多个线程共享)中取，而且一次取就取一大块，防止多个线程大量反复取内存加锁而延长获取时间</p></li></ul><p>​    </p><blockquote><p>内存图介绍</p></blockquote><ul><li><p><code>mcache</code></p><ul><li><p>小对象的内存分配直接走</p></li><li><p>size class 从 1 到 66，每个 class 两个 span（因为一个span存object，一个span存指针）</p></li><li><p>Span 大小是 <strong>8KB</strong>，按 span class 大小切分</p><p>每一个span都有一个描述者<strong>mspan</strong></p><p><img src="/img/Go_GC%E5%8E%9F%E7%90%86/image-20220208170041071.png" alt="image-20220208170041071"></p><ul><li>npages：分成多少页</li><li>allocBits：记录了每块内存分配的情况</li><li>gcmarkBits：记录了每块内存的引用情况，标记阶段对每块内存进行标记，有对象引用的内存标记为1，没有的标 记为 0</li><li>这两个位图的数据结构是完全一致的，标记结束则进行内存回收，回收的时候，<strong>将 allocBits 指 向 gcmarkBits，标记过的则存在，未进行标记的则进行回收</strong></li></ul></li></ul></li><li><p><code>mcentral</code></p><ul><li>Span 内的所有内存块都被占用时，没有剩余空间继续分配对象，mcache 会向 mcentral 申请1个 span，mcache 拿到 span 后继续分配对象</li><li>当 mcentral 向 mcache 提供 span 时，如果没有符合条件的 span，mcentral 会向 mheap 申请 span</li></ul></li><li><p><code>mheap</code></p><ul><li>当 mheap 没有足够的内存时，mheap 会向 OS (系统) 申请内存</li><li>Mheap 把 Span 组织成了树结构，而不是链表</li><li>然后把 Span 分配到 heapArena 进行管理，它包含地址映射和 span 是否包含指针等位图<ul><li>为了更高效的分配、回收和再利用内存</li></ul></li></ul></li></ul><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p><strong>Garbage Collection</strong></p><blockquote><p>内存回收的类型</p></blockquote><ul><li>引用计数（Python，PHP，Swift）<ul><li>对每一个对象维护一个引用计数，当引用该对象的对象被销毁的时候，引用计数减 1，当引用计数为 0 的时候，回 收该对象</li><li>优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收</li><li>缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价</li></ul></li><li>标记-清除（<strong>Golang</strong>）<ul><li>从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收</li><li>优点：解决引用计数的缺点</li><li>缺点：需要 STW（stop the word），即要暂停程序运行</li></ul></li><li>分代收集（Java）<ul><li>按照生命周期进行划分不同的代空间，生命周期长的放入老年代，短的放入新生代，新生代的回收频率高于老年代的频率</li></ul></li></ul><h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><blockquote><p>STW</p></blockquote><p><strong>Stop The World</strong></p><p>在垃圾回收机制 (GC) 中，Stop The World是一个重要阶段。顾名思义，当前运行的所有程序将被暂停（<strong>以确定当前内存的引用关系：知道哪些被引用，因为如果不暂停引用可能会发生变化</strong>），扫描内存的  <code>Root</code> 节点和添加 <code>写屏障</code></p><p>这个阶段的第一步，是抢占所有正在运行的goroutine，被抢占之后，这些goroutine会被悬停在一个相对安全的状态</p><p>处理器P(无论是正在运行的处理器还是已在idle列表中的处理器)，都会被标记成停止状态(stopped)，不再运行任何代码。调度器把每个处理的M从各自对应的处理器P分离出来，放到idle(M的休闲列表)列表中去</p><p>对于Goroutine本身，它们会被放到一个全局队列中等待</p><p>​    </p><blockquote><p>Root</p></blockquote><p>根对象是mutator (应用程序) <strong>不需要通过其他对象就可以直接访问到的对象</strong>。比如全局对象、局部对象，栈对象中的数据等。通过Root对象。可以追踪到其他存活的对象，进而进行标记</p><p>这个算法就是严格按照追踪式算法的思路来实现的</p><ul><li>Stop the Wrold</li><li>Mark：通过Root和Root直接间接访问到的对象，来寻找所有可达的对象，并进行标记</li><li>Sweep：对堆对象迭代，已标记的对象置位标记。所有未标记的对象加入freelist，可用于再分配</li><li>Start the Wrold</li></ul><p>这个算法最大的问是GC执行期间需要把整个程序完全暂停，朴素的Mark Sweep是整体STW，并且分配速度慢，内存碎片高</p><p>​    </p><p>在Go1.1是全局阶段STW，可能是秒级，Go1.3是标记过程要STW，因为对象引用关系如个人在标记阶段做了修改，会影响标记结果的正确性</p><p><strong>并发GC</strong>分为两层含义：</p><ul><li>每个mark或sweep本身是多个线程(协程)执行的 (concurrent)</li><li>mutator (应用程序) 和 collector 同时运行 (background)</li></ul><p>concurrent这一层是比较好实现的，GC时整体进行STW，那么对象引用关系不会再改变，<strong>对mark或者sweep任务进行分块</strong>，就能多个线程(协程)concurrent执行任务mark或sweep</p><p>对于backgroud这一层，也就是说mutator和mark、sweep同时运行，则相对复杂</p><ul><li>1.3以前的版本使用标记-清除的方式，整个过程都需STW</li><li>1.3版本分离了标记和清除的操作，标记过程STW，清除过程并发执行</li></ul><p>background sweep是比较容易实现的，因为mark后，哪些对象是存活，哪些是要被sweep是已知的，sweep的是不再引用的独享。sweep结束前，这些对象不会再分配到，所以sweep和mutator运行共存。无论全局还是栈不可能能访问的到这些对象，可以安全清理</p><p>1.5版本后在标记过程中使用<strong>三色标记法</strong>。标记和清扫都并发执行的，但标记阶段的前后需要STW一定时间来做GC的准备工作和栈的re-scan</p><h3 id="三色标记清除法"><a href="#三色标记清除法" class="headerlink" title="三色标记清除法"></a>三色标记清除法</h3><p><strong>Tri-color Mark &amp; Sweep</strong></p><p>三色标记清除法是对标记清除法的改进，标记清除法在整个执行时要求长时间 <code>STW</code>，Go从1.5版本开始改为三色标记法：初始将所有内存标记为白色，然后将roots加入待扫描队列(进入队列即被视为变为灰色)，然后并发goroutine扫描队列中的指针，如果指针还引用了其他指针，那么被引用的也进入队列(变为灰色)，被扫描的对象视为黑色(由灰色变为黑色)</p><ul><li>白色对象：潜在的垃圾，其内存可能会被垃圾回收器回收</li><li>黑色对象：活跃对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象，垃圾回收器不会扫描这些对象的子对象</li><li>灰色对象：潜在活跃对象，因为可能存在指向白色对象的外部指针，垃圾回收器会扫描这些对象的子对象</li></ul><p>​    </p><blockquote><p>工作流程</p></blockquote><p>Golang GC 的大部分处理是和用户代码并行的</p><ul><li>Mark：<ul><li>Mark Prepare: 初始化 GC 任务，包括开启写屏障 (write barrier) 和辅助 GC (mutator assist)，统计root对象的任 务数量等。这个过程需要STW</li><li>GC Drains: 扫描所有 root 对象，包括全局指针和 goroutine(G) 栈上的指针（扫描对应 G 栈时需停止该 G)，将其 加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。该过程后台并行执行</li></ul></li><li>Mark Termination：完成标记工作，重新扫描(re-scan)全局指针和栈。因为 Mark 和用户程序是并行的，所以在 Mark 过 程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下，这 个过程也是会 STW 的</li><li>Sweep：按照标记结果回收所有的白色对象，该过程后台并行执行</li><li>Sweep Termination：对未清扫的 span 进行清扫, 只有上一轮的 GC 的清扫工作完成才可以开始新一轮的 GC</li></ul><p>​    </p><blockquote><p>三色标记</p></blockquote><ul><li>GC 开始时，认为所有 object 都是白色，即垃圾</li><li>从 root 区开始遍历，被触达的 object 置成灰色</li><li>遍历所有灰色 object，将他们内部的引用变量置成灰色，自身置成黑色</li><li>循环第 3 步，直到没有灰色object 了，只剩下了黑白两种，白色的都是垃圾，可以被清除</li><li>对于黑色 object，如果在标记期间发生了写操作，<code>写屏障</code>会在真正赋值前将新对象标记为灰色</li><li>标记过程中，mallocgc 新分配的 object，会先被标记成黑色再返回 (本次就不清理了，留给下一轮GC) </li><li><strong>颜色内部实现的原理</strong>：每个span中有一个名为<code>gcmarkBits</code>的位图属性，该属性跟踪扫描，并将相应的位设置为1</li></ul><p><img src="/img/Go_GC%E5%8E%9F%E7%90%86/image-20220209102953725.png" alt="image-20220209102953725"></p><h3 id="Write-Barrier"><a href="#Write-Barrier" class="headerlink" title="Write  Barrier"></a><strong>Write  Barrier</strong></h3><p>1.5版本在标记过程中使用三色标记法。回收过程主要有四个阶段，其中，<strong>标记和清扫都并发执行</strong>的，但标记阶段的前后都需要STW一定时间来做GC的准备工作和re-scan (重新扫描，查询是否在标记过程中发生了内存引用的改变)</p><p>使用并发的垃圾回收，也就是多个Mutator (应用程序) 与Mark并发执行，想要在并发或者增量的标记算法中保证正确性，需要达成以下两种三色不变性(Tri-color invariant)中的任意一种</p><ul><li><strong>强三色不变性</strong>：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象</li><li><strong>弱三色不变性</strong>：黑色对象指向的白色对象必须包含一条灰色对象经由多个白色对象的可达路经(因黑色对象不会被扫描了，而有灰色对象指向白色，则白色对象还有机会被扫描)</li></ul><p><img src="/img/Go_GC%E5%8E%9F%E7%90%86/image-20210504193401144.png" alt="image-20210504193401144"></p><p>如图，如果e被或破坏了(B.e=nil)，则白色对象c必然会被视为垃圾，出现对象丢失的现象。如果这个白色对象下游还引用了其他对象，并且这条路径还是指向下游的唯一路径，那么他们也是必死无疑的</p><p>为了防止这种现象的产生，最简单的方法就是STW，直接禁止其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费现象，对所有的用户程序都有很大的影响，则如何在保证对象不丢失的情况下尽可能的提高GC效率，减少STW时间呢？</p><p>​    </p><blockquote><p><strong>Write Barrier - Dijkstra 插入写屏障</strong></p></blockquote><p><strong>插入屏障拦截将白色指针插入黑色对象的操作，标记其对应对象为灰色状态</strong>，这样就不存在黑色对象引用白色对象的情况了。满足强三色不变式，在插入指针f时将C对象标记为灰色</p><p>如果对栈上的写作拦截，那么流程代码会非常复杂，并且性能下降会非常大，得不偿失。根据局部性的原理来说，其实我们程序跑起来，大部分的其实都是操作在栈上，函数参数啊、函数调用导致的入栈和出栈、局部变量啊，协程栈，这些如果也弄起了写屏障，那么可想而知了，根本不现实，复杂度和性能就是越不过去的坎</p><ul><li>初始化GC任务，包括开启写屏障和辅助GC，统计root对象的任务数量，这个过程需要STW(但是非常快)</li><li>扫描所有对象，包括全局指针和goroutine栈上的指针(扫描对应G栈是需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，知道灰色队列为空，该过程后台并发执行</li><li>完成标记过程后，重新扫描(re-scan)全局指针和栈。因为Mark和mutator是并行的。所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候需要通过写屏障记录下来，re-scan再检查下，这个过程也是会STW的</li><li>按照标记结果回收所有白色对象，该过程后台并发执行</li></ul><p><img src="/img/Go_GC%E5%8E%9F%E7%90%86/image-20220209110713126.png" alt="image-20220209110713126"></p><p>​    </p><blockquote><p><strong>Write Barrier - Yuasa 删除写屏障</strong></p></blockquote><p>删除屏障也是拦截写操作的，但是是<strong>通过保护灰色对象到白色独享的路径不会断实现的，如果发生路径断裂则将白色对象标记为灰色对象</strong>。如上图中，删除指针e时将对象C标记为灰色，这样C下游的所有白色对象，即使会被黑色对象引用，最终也还是会被扫描标记的，满足了弱三色不变式。这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，只能在下一轮GC中被清理掉</p><p>​    </p><blockquote><p><strong>Write Barrier - 混合写屏障</strong></p></blockquote><p>Go1.8 混合写屏障结合了<code>Yuasa的删除写屏障</code>和<code>Dijkstra的插入写屏障</code></p><p>插入屏障和删除屏障各有优缺点，Djkstra的插入写屏障在标记开始时无需STW，可直接开始，并发执行，但是结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；Yuasa的删除写屏障则需要在GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象，但结束时无需STW</p><p>Golang的混合写屏障满足的是变形的弱三色不变式，同样允许黑色对象引用白色对象，白色对象处于灰色保护状态，但是只由堆上的灰色对象保护</p><p><img src="/img/Go_GC%E5%8E%9F%E7%90%86/image-20220209113153150.png" alt="image-20220209113153150"></p><p>由于结合了 Yuasa 的删除写屏障和 Dijksra 的插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再近些re-scan操作了，减少了STW的时间</p><p>为了移除占上的重扫描过程，除了引入混合屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色（留给下一轮GC），防止新分配的栈内存和堆内存中的对象被错误的回收，因为栈内存在标记阶段最终都会变为黑色，所以不需要重新扫描空间</p><h3 id="Sweep"><a href="#Sweep" class="headerlink" title="Sweep"></a>Sweep</h3><p>Sweep让Go知道哪些内存可以重新分配使用，然而，Sweep过程不会处理释放的对象内存置为0，而是在分配重新使用的时候，重新reset bit (取的时候才reset)</p><p>每一个span内有一个<code>bitmap allocBits</code>，它表示上一次GC之后每一个object的分配情况，1表示已分配，0表示未使用或释放</p><p>​    </p><p>GC将会启动去释放不再被使用的内存。在标记期间，GC会用一个位图<code>gcmarkBits</code>来跟踪在使用中的内存(黑色标记为0，白色标记为1)</p><p>正在被使用的内存被标记为黑色，然后当前执行并不能够达到的那些内存会被保持为白色</p><p>现在，我们可以使用<code>gcmarkBits</code>精确查看可用于分配的内存。<strong>Go使用gcmarkBits赋值allocBits(覆盖)，这个操作就是内存清理</strong></p><p><img src="/img/Go_GC%E5%8E%9F%E7%90%86/image-20220209113007090.png" alt="image-20220209113007090"></p><p>然而必须每个span都来一次类似的处理，需要耗费大量时间。Go的目标是在清理内存时不阻碍执行，并依次提供了两种策略</p><ul><li><p>在后台启动一个worker等待清理内存，一个一个mspan处理</p><p>当开始运行程序时，Go将设置一个后台运行的worker(唯一的任务就是去清理内存)，它将进入睡眠状态并等待内存阶段扫描</p></li><li><p>当申请分配内存时候lazy触发</p><p>当应用程序goroutine尝试在堆内存中分配新内存时，会触发该操作。清理导致的延迟和吞吐量降低被分散到每次内存分配时</p></li></ul><p>​    </p><p>清理内存阶段的第二种方式是即时执行，但是，由于这些内存已经被分发到每一个处理器P的本地缓存<code>mcache</code>中，因此很难追踪首先清理哪些内存。这就是为什么Go首先将所有内存段移动到<code>mcentral</code>的原因。然后，它会让本地缓存mcache再次请求它们，去即时清理</p><p><img src="/img/Go_GC%E5%8E%9F%E7%90%86/image-20220209113513568.png" alt="image-20220209113513568"></p><p>即时扫描确保所有内存段都会得到清理(节省资源)，同时不会阻塞程序执行</p><p>由于后台只有一个 worker 在清理内存块，清理过程可能会花费一些时间。但是，我们可能想知道如果另一个 GC 周期在一次清理过程中启动会发生什么。在这种情况下，这个运行 GC 的 Goroutine 就会在开始标记阶段前去协助完成剩余的清理工作。</p><h3 id="GC触发机制"><a href="#GC触发机制" class="headerlink" title="GC触发机制"></a>GC触发机制</h3><ul><li>内存分配量达到阀值触发 GC<ul><li>每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动 GC<ul><li>阀值 = 上次 GC 内存分配量 * 内存增长率</li><li>内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC</li></ul></li></ul></li><li>定期触发 GC<ul><li>默认情况下，最长 2 分钟触发一次 GC，这个间隔在 src/runtime/proc.go:forcegcperiod 变量中被声明</li></ul></li><li>手动触发<ul><li>程序代码中也可以使用 runtime.GC( ) 来手动触发 GC。这主要用于 GC 性能测试和统计</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络之传输层</title>
    <link href="/2022/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2022/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><strong>端到端，进程与进程的通信</strong></p><ul><li>使用端口 (Port) 来标记不同的网络进程</li><li>端口 (Port) 使用<strong>16比特位</strong>表示 (0~65535)</li></ul><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421105559761.png" alt="image-20210421105559761"></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><ul><li>UDP 用户数据报协议<ul><li>数据报：应用层传输过来一个完整的数据</li><li>对数据报不合并、不拆分</li></ul></li><li>UDP是一个非常简单的协议</li></ul><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421111238096.png" alt="image-20210421111238096"></p><ul><li><p>UDP 是<strong>无连接</strong>协议</p></li><li><p>UDP 不能保证可靠的交付数据</p><p>因为UDP协议头部简单，且无连接想发就发，无法保证数据在网络中是否丢失</p></li><li><p>UDP 是面向报文传输的</p><p>不会对报文做任何处理，而是直接塞进UDP的数据中发送出去</p></li><li><p>UDP没有<strong>拥塞控制</strong></p><p>UDP不管网络是否拥塞都会尽量把数据发送出去</p></li><li><p>UDP的<strong>首部开销</strong>很小</p></li></ul><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ul><li>TCP 传输控制协议</li><li>TCP协议是计算机网络中非常复杂的一个协议</li></ul><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421112430143.png" alt="image-20210421112430143"></p><ul><li><p>TCP是<strong>面向连接</strong>的协议</p></li><li><p>TCP的一个连接有两端(点对点通信)</p></li><li><p>TCP<strong>提供可靠</strong>的传输服务</p></li><li><p>TCP协议提供<strong>全双工</strong>的通信</p><p>两个连接都可以发送数据的接收数据</p></li><li><p>TCP是面向<strong>字节流</strong>的协议</p><p>对应该层的数据进行<strong>拆分</strong>成一段一段的分别发送然后进行<strong>合并</strong></p></li></ul><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210422163236382.png" alt="image-20210422163236382"></p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><blockquote><p><strong>可靠传输的基本原理</strong></p></blockquote><p><strong>停止等待协议</strong></p><ul><li><p>发送方给接收方发送消息1后停止，等待接收方发送确认消息后继续发送消息2</p></li><li><p>出现差错的情况：通过<strong>超时重传</strong>来保证可靠传输</p><ul><li>发送消息在路上丢失了</li><li>确认消息在路上丢失了</li><li>确认的消息很久才到</li></ul></li><li><p><strong>超时定时器</strong>：每发送一个消息，都需要设置一个定时器</p></li><li><p>停止等待协议是最简单的可靠传输协议</p></li><li><p>停止等待协议对<strong>信道的利用率</strong>不高</p></li></ul><p>​    </p><p><strong>连续ARQ协议</strong></p><ul><li>ARQ ：自动重传请求</li><li><strong>批量发送和确认</strong></li></ul><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421124445875.png" alt="image-20210421124445875"></p><ul><li><p>拥有<strong>滑动窗口</strong>，批量发送后收到确认再将窗口向前滑动继续发送窗口内的数据</p></li><li><p>并不需要对每一个报文都确认，而是采用<strong>累计确认</strong>的方法，比如接收到了5就代表前五个数据已收到，窗口向后滑动五个位置 (大大减少确认报文的数量以<strong>提升网络效率</strong>)</p></li></ul><p>​    </p><blockquote><p><strong>TCP协议的可靠传输</strong></p></blockquote><ul><li><p>TCP的可靠传输基于连续ARQ协议</p></li><li><p>TCP的滑动窗口是以字节为单位的</p></li><li><p>如果<strong>没有按序</strong>收到<strong>确认号</strong>，过超时时间(<strong>超时定时器</strong>)就会重传</p><ul><li><p>选择重传：选择重传指定需要重传的字节，是一个边界，是一个字节段 （比如TCP报文中的选项存了1000和1500表示重传1000到1500边界的字节）</p></li><li><p>每一个字节都有惟一的32位序号，TCP报文的序号也是指一个字节段</p></li></ul></li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul><li><p>流量控制指让<strong>发送方发送速率不要太快</strong></p></li><li><p>流量控制是使用<strong>滑动窗口</strong>来实现的</p><p>窗口指明允许对方发送的数据量</p></li><li><p>通过<strong>窗口大小</strong>控制对方发送速率</p><ul><li>在向发送方发送确认消息时可以<strong>指定窗口的大小</strong>(对方可以发送的数据大小)，如果指定为0发送方将等待</li><li>如果在发送方等待，接收方发送窗口大小的消息时消息丢失，就会出现<strong>死锁</strong>的情况(发送方和接收方都在等待对方传消息)，这时需要<strong>坚持定时器</strong></li></ul></li><li><p><strong>坚持定时器</strong></p><ul><li>当接收到窗口消息为0的消息，则启动<strong>坚持定时器</strong></li><li>坚持定时器每隔一段时间发送一个<strong>窗口探测报文</strong></li></ul></li></ul><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p><strong>拥塞</strong></p><ul><li>一条数据链路经过非常多的设备</li><li>数据链路层中各个部分都有可能成为网络传输的瓶颈</li><li>网络对硬件设备的要求大于可用资源导致拥塞</li></ul><p>​    </p><ul><li>流量控制考虑的是<strong>点对点</strong>通信量的控制</li><li>拥塞控制考虑<strong>整个网络</strong>，是全局性的考虑</li></ul><p>​    </p><ul><li>报文超时则认为是拥塞</li></ul><p>​    </p><p><strong>慢启动算法</strong></p><ul><li><p>由小到大逐渐增加发送数据量（发送数据报文的数量）</p></li><li><p>每收到一个报文确认，就加一（1 2 4 8 16…）指数增长</p></li><li><p>当增长到<strong>慢启动阈值</strong>就不增长了，就会启动<strong>拥塞避免算法</strong></p></li></ul><p>​    </p><p><strong>拥塞避免算法</strong></p><ul><li>维护一个拥塞窗口</li><li>只要网络不拥塞 (报文不超时)，就<strong>试探着</strong>拥塞窗口调大 (16 17 18…)</li></ul><p>​    </p><p>TCP的拥塞控制还是尽可能结合自身考虑，只要网络不拥塞就尽可能发送更多的数据到网络中去，只要拥塞发生了就减少自己所发送的数据量，以降低网络中设备的压力</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>TCP标记：存在TCP报文中，占6位，每位各有不同含义<ul><li><strong>ACK</strong> ：确认位，ACK=1。确认号才生效</li><li><strong>SYN</strong>：同步位，SYN=1,表示连接请求报文</li><li><strong>FIN</strong>：终止位，FIN=1，表示释放连接</li></ul></li></ul><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210422163606481.png" alt="image-20210422163606481"></p><p><strong>seq</strong>：序列号</p><p><strong>ack</strong>：确认号（ack=x+1 表示想要收到x+1的序列号的值）</p><p>​    </p><blockquote><p>为什么发送方要发出第三个确认报文(为什么要进行三次握手)？</p></blockquote><ul><li>避免<strong>已经失效的连接请求报文</strong>传送到对方，<strong>引起错误</strong></li><li>如果第一次发送后发送方迟迟得不到回应就会发出第二次请求<ul><li>如果只有两次握手，在重新发的请求确认握手后，后来到的发送请求会再次建立连接，引发错误(如果客户端已经连接超时失败，放弃连接了。这个时候超时的信号又到了服务端，服务第二次握手，认为建立了连接，服务器资源就被浪费了)</li><li>三次握手中，第二次到达的报文发出第三次请求后，就会忽略后到的请求</li></ul></li></ul><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210422164124039.png" alt="image-20210422164124039"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210422165201150.png" alt="image-20210422165201150"></p><ul><li>发送方发出请求断开的报文后，接收方回应受到请求，此时发送方以不能发送报文了，<strong>但接收方还可以继续发送报文</strong>，待接收方信息发送完成后给发送方发送消息表示消息已经发送完成</li></ul><p>​    </p><p><strong>等待计时器</strong></p><ul><li><p>等待<strong>2MSL</strong>的时间</p><p>MSL：最长报文段寿命</p><p>MSL建议设置为<strong>2分钟</strong></p><ul><li>为什么要等待<strong>2MSL</strong>？<ul><li>最后一个报文是没有确认的</li><li>确保发送方的<strong>ACK</strong>可以到到接收方</li><li>2MSL时间内没有收到，则接收方会重发，重复第三次挥手的动作</li><li>确保当前连接的所有报文都已经过期</li></ul></li></ul></li><li><p>只有在等待计时器结束后才会释放端口</p></li></ul><h2 id="套接字与套接字编程"><a href="#套接字与套接字编程" class="headerlink" title="套接字与套接字编程"></a><strong>套接字与套接字编程</strong></h2><p>IP与端口的组合（ <strong>IP:Port</strong> ）又称为套接字</p><ul><li><p>套接字(<strong>Socket</strong>)是抽象概念，表示TCP连接的一端</p></li><li><p>通过套接字可以进行数据发送或接收</p></li><li><p>两个套接字既可以确认一条TCP的连接 <strong>IP:Port ↔ IP:Port</strong></p><p><strong>TCP连接由两个套接字组成   CS架构</strong></p></li></ul><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210422171153920.png" alt="image-20210422171153920"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法排序之选择、插入、冒泡、归并排序</title>
    <link href="/2022/02/07/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5&amp;%E9%80%89%E6%8B%A9&amp;%E5%86%92%E6%B3%A1&amp;%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/02/07/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5&amp;%E9%80%89%E6%8B%A9&amp;%E5%86%92%E6%B3%A1&amp;%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h2><ul><li>复杂度：<strong>n²</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SelectionSort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>      <span class="hljs-keyword">var</span> max = i<br>      <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(arr); j++ &#123;<br>         <span class="hljs-keyword">if</span> arr[j] &gt; arr[max] &#123;<br>            max = j<br>         &#125;<br>      &#125;                     <br>      arr[i], arr[max] = arr[max], arr[i]<br>   &#125;<br>   fmt.Println(arr)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序法"><a href="#插入排序法" class="headerlink" title="插入排序法"></a>插入排序法</h2><p>原理是将 <code>arr[i]</code> 插入到数组前面合适的位置<br>和选择排序相比特性是，程序会<strong>提前终止内循环</strong>即对于极端情况(如有序数组)则复杂度为 <strong>n</strong>，而选择排序始终是 <strong>n²</strong><br>对于<strong>近乎有序数组</strong>(银行处理业务)，插入排序法是更好的选择(和归并排序和快排相比)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertionSort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br><span class="hljs-keyword">for</span> j := i; j<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span>; j-- &#123;<br><span class="hljs-keyword">if</span> arr[j<span class="hljs-number">-1</span>] &gt; arr[j] &#123; <span class="hljs-comment">//不用记录i的下标，因为比较的两个数始终是相邻的，用j-1表示即可</span><br>arr[j], arr[j<span class="hljs-number">-1</span>] = arr[j<span class="hljs-number">-1</span>], arr[j]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertionSort2</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>      <span class="hljs-comment">//内循环优化</span><br>      <span class="hljs-keyword">for</span> j := i; j<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j<span class="hljs-number">-1</span>] &gt; arr[j]; j-- &#123;<br>       arr[j], arr[j<span class="hljs-number">-1</span>] = arr[j<span class="hljs-number">-1</span>], arr[j]<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a><strong>再优化</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertionSort2</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>      <span class="hljs-comment">//交换元素优化为赋值元素 交换可看成是三次赋值</span><br>      <span class="hljs-keyword">var</span> j <span class="hljs-keyword">int</span><br>      num := arr[i]<br>      <span class="hljs-keyword">for</span> j = i; j<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j<span class="hljs-number">-1</span>] &gt; num; j-- &#123; <br>         arr[j] = arr[j<span class="hljs-number">-1</span>] <span class="hljs-comment">//每次覆盖前j前面的数字已经全部有序，只是将j插入到前面有序数组相应的位置，所以才能直接用前一个数覆盖后一个数，当遇到不能覆盖的位置时，此时再将之前保留的num放在该位置上</span><br>      &#125;<br>      arr[j]=num<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123;<br>      <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(arr)-i<span class="hljs-number">-1</span>; j++ &#123;<br>         <span class="hljs-keyword">if</span> arr[j] &gt; arr[j+<span class="hljs-number">1</span>] &#123;<br>            arr[j], arr[j+<span class="hljs-number">1</span>] = arr[j+<span class="hljs-number">1</span>], arr[j]<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>每次记录是否进行了冒泡操作，没有进行冒泡时说明该数组已有序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BubbleSort2</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123;<br>      isSwapped := <span class="hljs-literal">false</span><br>      <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(arr)-i<span class="hljs-number">-1</span>; j++ &#123;<br>         <span class="hljs-keyword">if</span> arr[j] &gt; arr[j+<span class="hljs-number">1</span>] &#123;<br>            arr[j], arr[j+<span class="hljs-number">1</span>] = arr[j+<span class="hljs-number">1</span>], arr[j]<br>            isSwapped = <span class="hljs-literal">true</span><br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> !isSwapped &#123; <span class="hljs-comment">//如果这一轮数组没有进行交换，说明整个数组已经有序</span><br>         <span class="hljs-keyword">break</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="再优化-1"><a href="#再优化-1" class="headerlink" title="再优化"></a><strong>再优化</strong></h3><p>因为i不仅表示<strong>循环的轮数</strong>，还表示数组<strong>已排好序的 i 位数</strong></p><p>记录每次进行<strong>交换的下标</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BubbleSort3</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; &#123;<br>      lastSwappedIndex := <span class="hljs-number">0</span><br>      <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(arr)-i<span class="hljs-number">-1</span>; j++ &#123;<br>         <span class="hljs-keyword">if</span> arr[j] &gt; arr[j+<span class="hljs-number">1</span>] &#123;<br>            arr[j], arr[j+<span class="hljs-number">1</span>] = arr[j+<span class="hljs-number">1</span>], arr[j]<br>            lastSwappedIndex = j + <span class="hljs-number">1</span> <span class="hljs-comment">//最后一个交换的下标</span><br>         &#125;<br>      &#125;<br>      i = <span class="hljs-built_in">len</span>(arr) - lastSwappedIndex <span class="hljs-comment">//i不仅表达的是多少轮，也表示数组最后i位以排好序</span><br>      <span class="hljs-comment">//有了最后交换的下标，表示之后没有进行交换过，表示下标之后的已有序</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序法"><a href="#归并排序法" class="headerlink" title="归并排序法"></a>归并排序法</h2><p><img src="/img/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5&%E9%80%89%E6%8B%A9&%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20210316210749343.png" alt="image-20210316210749343"></p><p><strong>看复杂度就看递归树的层数</strong></p><p><img src="/img/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5&%E9%80%89%E6%8B%A9&%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20210316212030686.png" alt="image-20210316212030686"></p><ul><li><p>其复杂度是<strong>nlogn</strong></p></li><li><p>采用的是<strong>分治思想</strong></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> l &gt;= r &#123;<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   mid := l+(r-l) / <span class="hljs-number">2</span> <span class="hljs-comment">//因为</span><br>   <span class="hljs-comment">// l+r如果超出了32位则会有bug</span><br>   sort(arr, l, mid)<br>   sort(arr, mid+<span class="hljs-number">1</span>, r)<br>   merge(arr, l, mid, r)<br>&#125;<br><br><span class="hljs-comment">//归并排序法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, mid, r <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   temp:=<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,r-l+<span class="hljs-number">1</span>)<br>   <span class="hljs-built_in">copy</span>(temp, arr[l:r+<span class="hljs-number">1</span>])<br>   i := l<br>   j := mid + <span class="hljs-number">1</span><br><br>   <span class="hljs-comment">//每轮循环为arr[k]赋值</span><br>   <span class="hljs-keyword">for</span> k := l; k &lt;= r; k++ &#123;<br>      <span class="hljs-keyword">if</span> i &gt; mid &#123; <span class="hljs-comment">//如果i越界了则说明给定界限的数组前一半以前排完了，则直接将后一半剩下的数依次放入</span><br>         arr[k] = temp[j-l] <span class="hljs-comment">//因为temp是给定界限的数组，有l的偏移量</span><br>         j++<br>         <span class="hljs-keyword">continue</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> j &gt; r &#123;<br>         arr[k] = temp[i-l]<br>         i++<br>         <span class="hljs-keyword">continue</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> temp[i-l] &lt;= temp[j-l] &#123; <span class="hljs-comment">//前半部分和后半部分进行比较，谁小就先放谁</span><br>         arr[k] = temp[i-l]<br>         i++<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         arr[k] = temp[j-l]<br>         j++<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//归并排序法的优化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MergeSort2</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   temp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(arr)) <span class="hljs-comment">//进行内存优化，只开一次空间，防止每次merge时的开辟空间</span><br>   <span class="hljs-built_in">copy</span>(temp, arr)<br>   sort2(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>, temp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort2</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>, temp []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> r-l &lt; <span class="hljs-number">15</span> &#123;<br>      insertionSort(arr, l, r) <span class="hljs-comment">//选择使用插入排序法，因为对于小规模的排序，插入排序法的常数小，反而耗时更少</span><br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   mid := l + (r-l)/<span class="hljs-number">2</span> <span class="hljs-comment">//因为</span><br>   <span class="hljs-comment">// l+r如果超出了32位则会有bug</span><br>   sort2(arr, l, mid, temp)<br>   sort2(arr, mid+<span class="hljs-number">1</span>, r, temp)<br><br>   <span class="hljs-keyword">if</span> arr[mid] &gt; arr[mid+<span class="hljs-number">1</span>] &#123; <span class="hljs-comment">//如果左数组的最大都比有数组最小还要小，则不需要进行并归</span><br>      merge2(arr, l, mid, r, temp)<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//归并排序法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge2</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, mid, r <span class="hljs-keyword">int</span>, temp []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-built_in">copy</span>(temp[l:r+<span class="hljs-number">1</span>], arr[l:r+<span class="hljs-number">1</span>])<br>   i := l<br>   j := mid + <span class="hljs-number">1</span><br><br>   <span class="hljs-comment">//每轮循环为arr[k]赋值</span><br>   <span class="hljs-keyword">for</span> k := l; k &lt;= r; k++ &#123;<br>      <span class="hljs-keyword">if</span> i &gt; mid &#123; <span class="hljs-comment">//如果i越界了则说明给定界限的数组前一半以前排完了，则直接将后一半剩下的数依次放入</span><br>         arr[k] = temp[j] <span class="hljs-comment">//此时，temp也是从l开始取，则不需要偏移量</span><br>         j++<br>         <span class="hljs-keyword">continue</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> j &gt; r &#123;<br>         arr[k] = temp[i]<br>         i++<br>         <span class="hljs-keyword">continue</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> temp[i] &lt;= temp[j] &#123;<br>         arr[k] = temp[i]<br>         i++<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         arr[k] = temp[j]<br>         j++<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//如果是有序数组，则merge不会执行则在递归树中，每一个叶子结点复杂度都是1，则总的复杂度为n+2/n+4/n+.... 其复杂度为n</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := l; i &lt;= r; i++ &#123;<br>      <span class="hljs-keyword">var</span> j <span class="hljs-keyword">int</span><br>      num := arr[i]<br>      <span class="hljs-keyword">for</span> j = i; j<span class="hljs-number">-1</span> &gt;= l &amp;&amp; arr[j<span class="hljs-number">-1</span>] &gt; num; j-- &#123;<br>         arr[j] = arr[j<span class="hljs-number">-1</span>]<br>      &#125;<br>      arr[j] = num<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>leetcode 剑指offer51 求逆序数对个数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> Res <span class="hljs-keyword">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>   Res = <span class="hljs-number">0</span><br>   temp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br>   sortLeetcode(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>, temp)<br>   <span class="hljs-keyword">return</span> Res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortLeetcode</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>, temp []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> l &gt;= r &#123;<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   mid := l + (r-l)/<span class="hljs-number">2</span><br>   sortLeetcode(arr, l, mid, temp)<br>   sortLeetcode(arr, mid+<span class="hljs-number">1</span>, r, temp)<br>   mergeLeetcode(arr, l, mid, r, temp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeLeetcode</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, l, mid, r <span class="hljs-keyword">int</span>, temp []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-built_in">copy</span>(temp[l:r+<span class="hljs-number">1</span>], arr[l:r+<span class="hljs-number">1</span>])<br>   i := l<br>   j := mid + <span class="hljs-number">1</span><br><br>   <span class="hljs-keyword">for</span> k := l; k &lt;= r; k++ &#123;<br>      <span class="hljs-keyword">if</span> i &gt; mid &#123;<br>         arr[k] = temp[j]<br>         j++<br>         <span class="hljs-keyword">continue</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> j &gt; r &#123;<br>         arr[k] = temp[i]<br>         i++<br>         <span class="hljs-keyword">continue</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> temp[i] &lt;= temp[j] &#123;<br>         arr[k] = temp[i]<br>         i++<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         arr[k] = temp[j]<br>         Res+=mid-i+<span class="hljs-number">1</span> <span class="hljs-comment">//在这里如果右数组j的值比i小，则说明从i到mid的数都比j大</span><br>         j++<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go使用Jaeger实现分布式链路追踪</title>
    <link href="/2021/12/14/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <url>/2021/12/14/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="了解分布式链路追踪"><a href="#了解分布式链路追踪" class="headerlink" title="了解分布式链路追踪"></a>了解分布式链路追踪</h1><h2 id="什么是分布式链路追踪？"><a href="#什么是分布式链路追踪？" class="headerlink" title="什么是分布式链路追踪？"></a>什么是分布式链路追踪？</h2><ul><li>分布式链路追踪式用来查看和了解复杂的微服务间交互中的整个活动链</li><li>现代的云原生软件开发十分依赖微服务，因为每个独立的服务提供不同的核心功能。当用户在应用中发出请求时，许多单独的服务器都会作出响应，产生相应的结果</li><li>应用中的一个调用可能会涉及几十项彼此交互的服务。当出现问题时，开发人员和工程师该如何查明问题所在？所以需要一种跟踪所有连接的方法，就是分布式链路追踪</li></ul><h2 id="什么是OpenTracing"><a href="#什么是OpenTracing" class="headerlink" title="什么是OpenTracing?"></a>什么是OpenTracing?</h2><p><code>OpenTracing</code>是CNCF托管的分布式追踪项目，官方定位是针对分布式系统的追踪的API标准库，旨在为不同的分布式追踪系统提供统一的对外API接入层。它位于<strong>应用程序/类库</strong>和<strong>追踪或日志分析程序</strong>之间。</p><blockquote><p><strong>OpenTracing 数据模型</strong></p></blockquote><ul><li><p><strong>Trace</strong> 事物在分布式系统中移动时的描述</p></li><li><p><strong>Span</strong> 一种命名的、定时的操作，表示工作流的一部分，<code>span</code>中包含一下状态</p><ul><li><strong>Span Tag</strong>，一组键值对构成的 Span 标签集合。键值对中，键必须为 string，值可以是字符串，布尔，或者数字类型。</li><li><strong>Span Log</strong>，一组 span 的日志集合。每次 log 操作包含一个键值对，以及一个时间戳。</li></ul></li><li><p><strong>Span Contenxt</strong> 携带分布式事务的跟踪信息，包括当它通过网络或消息总线将服务传递给服务时。Span上下文包含Trace标识符、Span标识符和跟踪系统需要传播到下游服务的任何其他数据</p></li></ul><p>特别说明，一条 <strong>Trace</strong>（调用链）可以被认为是一个由多个 <strong>Span</strong> 组成的有向无环图（DAG图），<strong>Span</strong> 与 <strong>Span</strong> 的关系被命名为 <strong>References</strong>。Trace调用链可以用树形结构或者基于时间轴的时序图表示。下图为树形结构表示调用关系：</p><p><img src="/img/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/image-20211202102756151.png" alt="image-20211202102756151"></p><p>有时，使用<strong>时间轴</strong>来可视化Trace会更容易，如下图</p><p><img src="/img/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/image-20211202102729427.png" alt="image-20211202102729427"></p><h2 id="什么是Jaeger"><a href="#什么是Jaeger" class="headerlink" title="什么是Jaeger?"></a>什么是Jaeger?</h2><p>分布式追踪系统种类繁多，但是核心步骤有三个：代码埋点、数据存储和查询展示</p><p>Jaeger是Uber推出的一款开源分布式追踪系统，<strong>兼容OpenTracing API</strong>，它用于<strong>监视和诊断基于微服务的分布式系统</strong>，分布式追踪系统用于记录请求范围内的信息，例如：一次远程方法调用的执行过程和耗时。是我们排查问题和系统性能的利器</p><blockquote><p><strong>Jaeger的优点</strong></p></blockquote><ul><li>兼容<code>OpenTracing AP</code>I，写起来方便简单</li><li><code>UI</code>相较于Zipkin更加直观和丰富</li><li><code>sdk</code>比较丰富，go语言编写，支持Go、Java、Python、C++、C#、Node</li><li>上传采用<code>udp</code>传输，效率高速度快</li><li>后台存储支持<code>Cassandra</code>、<code>es</code>、<code>kafka</code></li></ul><blockquote><p><strong>Jaeger架构图</strong></p></blockquote><p><img src="/img/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/image-20211202105921391.png" alt="image-20211202105921391"></p><blockquote><p><strong>Jaeger组件介绍</strong></p></blockquote><ul><li><p><strong>jaeger-client</strong>：<code>jaeger</code> 的客户端，实现了<code>opentracing</code>协议 开销很小</p></li><li><p><strong>jaeger-agent</strong>：<code>jaeger client</code>的一个代理程序，client将收集到的调用链数据发给agent，然后由agent发给collector</p></li><li><p><strong>jaeger-collector</strong>：负责接收<code>jaeger client</code>或者<code>jaeger agent</code>上报上来的调用链数据，然后做一些校验，比如时间范围是否合法等，最终会经过内部的处理存储到后端存储</p></li><li><p><strong>jaeger-query</strong>：专门负责调用链查询的一个服务，有自己独立的UI</p></li><li><p><strong>jaeger-ingester</strong>：中文名称“摄食者”，可用从kafka读取数据然后写到<code>jaeger</code>的后端存储，比如<code>Cassandra</code>和<code>Elasticsearch</code></p></li></ul><p>其中j<code>aeger-collector</code>和<code>jaeger-query</code>是必须的，其余的都是可选的，我们没有采用<code>agent</code>上报的方式，而是让客户端直接通过<code>endpoint</code>上报到<code>collector</code>。</p><h1 id="使用Jaeger"><a href="#使用Jaeger" class="headerlink" title="使用Jaeger"></a>使用Jaeger</h1><blockquote><p><strong>引用相关库</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/opentracing/opentracing-<span class="hljs-keyword">go</span><br><span class="hljs-keyword">go</span> get -u github.com/uber/jaeger-client-<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p><strong>使用Jaeger</strong></p></blockquote><p><strong>初始化jaeger</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>tracer opentracing.Tracer<br>closer io.Closer<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initJaeger</span><span class="hljs-params">(serviceName <span class="hljs-keyword">string</span>)</span></span>&#123;<br>cfg := &amp;config.Configuration&#123;<br>    Sampler: &amp;config.SamplerConfig&#123; <span class="hljs-comment">//采样类型设置</span><br>        Type:  <span class="hljs-string">&quot;const&quot;</span>, <br>        Param: <span class="hljs-number">1</span>,<br>    &#125;,<br>    Reporter: &amp;config.ReporterConfig&#123; <span class="hljs-comment">// 采样接口设置</span><br>        LogSpans: <span class="hljs-literal">true</span>,<br>        LocalAgentHostPort:<span class="hljs-string">&quot;xxx:6831&quot;</span>,<br>    &#125;,<br>&#125;<br>cfg.ServiceName = serviceName <span class="hljs-comment">// 采集服务器名字 是必要的</span><br><br>tracer, closer, _ = cfg.NewTracer( <span class="hljs-comment">// 生成jaeger tracer</span><br>config.Logger(jaeger.StdLogger), <span class="hljs-comment">// 每次调用时打印日志</span><br>)<br><br>opentracing.SetGlobalTracer(tracer) <span class="hljs-comment">// 生成全局单例tracer   </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>SamplerConfig</code>用于设置采样类型，<code>Type</code>分为：</p><ul><li><strong>const</strong>：全量采集。<code>param</code>采样率设置0,1 分别对应打开和关闭</li><li><strong>probabilistic</strong> ：概率采集。<code>param</code>默认万份之一，0~1之间取值，</li><li><strong>rateLimiting</strong> ：限速采集。<code>param</code>每秒采样的个数</li><li><strong>remote</strong> ：动态采集策略。<code>param</code>值与<code>probabilistic</code>的参数一样。在收到实际值之前的初始采样率。改值可以通过环境变量的<code>JAEGER_SAMPLER_PARAM</code>设定</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">记录关于Span相关信息<br><span class="hljs-comment">//method 1、Adds a tag to the span.</span><br>SetTag(key <span class="hljs-keyword">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;) Span<br><br><span class="hljs-comment">//method 2、有类型检查、但相较LogKV比较麻烦</span><br>LogFields(fields ...log.Field)<br><br><span class="hljs-comment">//method 3、缺乏类型检查</span><br>LogKV(alternatingKeyValues ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>在最初调用时(放在中间件等)生成ctx，并将span注入进去</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">span, ctx := opentracing.StartSpanFromContext(ctx, name) <span class="hljs-comment">// 开始生成子span</span><br><span class="hljs-keyword">defer</span> span.Finish()<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>通过ctx拿到span，可以将kv注入进去</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setSpanLog</span><span class="hljs-params">(ctx context.Context,msg <span class="hljs-keyword">string</span>,level <span class="hljs-keyword">string</span>)</span></span>&#123;<br>    span := opentracing.SpanFromContext(ctx) <span class="hljs-comment">// 获取ctx中的span</span><br>span.LogFields(log.String(<span class="hljs-string">&quot;event&quot;</span>, msg)) <span class="hljs-comment">// 注册kv键值对</span><br>    span.LogFields(log.String(<span class="hljs-string">&quot;level&quot;</span>, level))<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>将jaeger集成到micro中</strong></p><p><code>micro</code>插件中提供了4种<code>wrapper</code>，分别用于不同服务类型： <code>WrapHandler( )</code> server中间件 、<code>WrapCall( )</code> call中间件 、<code>WrapClient( )</code> client中间件 、 <code>WrapSubscriber( ) </code>订阅中间件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">srv := micro.NewService(<br>micro.WrapClient(<br>opentracing.NewClientWrapper(trace.Tracer()),<br>logger.LogClient,<br>),<br>micro.WrapHandler(<br>opentracing.NewHandlerWrapper(trace.Tracer()),<br>logger.LogHandler,<br>),<br>    micro.WrapSubscriber(<br>opentracing.NewSubscriberWrapper(trace.Tracer()),<br>),<br>micro.WrapCall(<br>opentracing.NewCallWrapper(trace.Tracer()), <br>),<br>)<br></code></pre></td></tr></table></figure><h1 id="测试部署"><a href="#测试部署" class="headerlink" title="测试部署"></a>测试部署</h1><blockquote><p><strong>快速搭建环境</strong></p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> -d -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 -p5775:5775/udp -p6831:6831/udp -p6832:6832/udp \</span><br><span class="bash">  -p5778:5778 -p16686:16686 -p14268:14268 -p9411:9411 jaegertracing/all-in-one:latest</span><br></code></pre></td></tr></table></figure><p>​    </p><table><thead><tr><th>端口</th><th>协议</th><th>组件</th><th>功能</th></tr></thead><tbody><tr><td>5775</td><td>UDP协议</td><td>agent</td><td>接受zipkin.thrift紧凑型节俭协议（不推荐使用，仅由旧版客户端使用）</td></tr><tr><td>6831</td><td>UDP协议</td><td>agent</td><td>接受jaeger.thrift紧凑型节俭协议</td></tr><tr><td>6832</td><td>UDP协议</td><td>agent</td><td>jaeger.thrift通过二进制节俭协议接受</td></tr><tr><td>5778</td><td>HTTP</td><td>agent</td><td>服务配置</td></tr><tr><td>16686</td><td>HTTP</td><td>query</td><td>服务前端</td></tr><tr><td>14268</td><td>HTTP</td><td>collector</td><td>jaeger.thrift直接接受客户</td></tr><tr><td>14250</td><td>HTTP</td><td>collector</td><td>接受 model.proto</td></tr><tr><td>9411</td><td>HTTP</td><td>collector</td><td>Zipkin兼容端点（可选）</td></tr></tbody></table><p>​    </p><p>成功启动后，可以通过<code>http://xxx:16686</code>访问 <code>Jaeger-UI</code></p><p><img src="/img/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/image-20211202141018674.png" alt="image-20211202141018674"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go标准化</title>
    <link href="/2021/10/15/Go%E4%BB%A3%E7%A0%81%E6%A0%87%E5%87%86%E5%8C%96/"/>
    <url>/2021/10/15/Go%E4%BB%A3%E7%A0%81%E6%A0%87%E5%87%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近将公司的一个项目代码进行初步的标准化，在过程中也有一些感悟和收获，进行简要的记录</p><p>项目代码注重标准化可以帮助我们写出高质量的代码</p><h1 id="Go写法标准化"><a href="#Go写法标准化" class="headerlink" title="Go写法标准化"></a>Go写法标准化</h1><ul><li><p>不要将<code>interface</code>做为万能的传递类型，不明确传递类型会降低代码的清晰度，<code>interface</code>类型可以代表任意类型，编译器不知道参数会是什么类型，只有运行时才知道，因此**只能分配到堆上(增加GC压力)**；并且如果接收方也是<code>interface</code>，则随意传递值会导致不可预估的后果(在twice中<code>db层</code>就用interface接收<code>control层</code>传的model是完全错误的)</p></li><li><p>变量和函数命名规范，要有意义，看名知意且尽量简介，驼峰命名，动作+对象，不要在函数里创建大写开头的变量</p></li></ul><ul><li><p>error返回</p><ul><li>关于<code>error</code>的原则是遇到err就进行判定<code>err!=nil</code>而不是<code>err==nil</code>，因为后者就会将正确包在括号里，一层一层如套娃一样，不美观也不优雅        </li></ul><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err==<span class="hljs-literal">nil</span>&#123;<br>    <span class="hljs-keyword">if</span> err==<span class="hljs-literal">nil</span>&#123;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>遇到<code>err</code>就要进行处理，而不是用匿名变量，唯一的对<code>err</code>都不关心，除非对返回结果也不关心</p></li><li><p>很多说go语言语法丑陋的，就是因为错误的返回方式，但是在代码风格上也可以进行优化避免大量的 <code>if err!=nil</code></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">err:=xxxFunction()<br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br><br>&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-keyword">if</span> err:=xxxFunction();err!=<span class="hljs-literal">nil</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DBxxxOperate</span><span class="hljs-params">(xx model)</span><span class="hljs-title">error</span></span>&#123;<br>    err:=DB.Create(&amp;xx).Error<br>    <span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>   <br>&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DBxxxOperate</span><span class="hljs-params">(xx model)</span><span class="hljs-title">error</span></span>&#123;<br>    <span class="hljs-keyword">return</span> DB.Create(&amp;xx).Error  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>对野生goroutine进行兜底保护</strong></p><p>因为<code>gin</code>框架已经对每一个接口进行了兜底保护，即使发送panic也不会宕机(<code>panic</code>),但是如果在接口中使用了<strong>野生goroutine并且在里面发升了<code>panic</code>，那么整个程序都会崩溃！(包括主程序)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <br>      <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//兜底保护</span><br>          <span class="hljs-keyword">if</span> err:=<span class="hljs-built_in">recover</span>();err!=<span class="hljs-literal">nil</span>&#123;<br>              logger(<span class="hljs-string">&quot;happen panic!&quot;</span>)<br>              ...<br>          &#125;<br>      &#125;<br>    xxx()<br>  &#125;()<br></code></pre></td></tr></table></figure></li></ul><h1 id="DB层标准化"><a href="#DB层标准化" class="headerlink" title="DB层标准化"></a>DB层标准化</h1><ul><li><p>返回时返回<code>error</code>而不是自定义的<code>rsp</code>结构体(从而到<code>control层</code>后直接作为数据返回给客户端)，<code>db层</code>只是完成数据库相关操作，如果在其他也需要该<code>db层</code>返回的数据并且不需要<code>rsp</code>这样重量级的返回，则需要返回到control会做进一步处理，并且会增加<code>db层</code>的耦合度</p></li><li><p>不要<code>在db层</code>做业务逻辑的操作，业务逻辑操作就该丢到<code>control层</code>，<code>db层</code>只用来做好数据库信息的操作即可，做到功能内聚</p><p>比如对查询到的数据数组进行进一步的操作时，需要将返回至<code>control层</code>再操作，而不是在<code>db层</code>操作后再返回给<code>control层</code></p></li><li><p><del>在db层的操作只有对于Find操作时需要传递指针的(因为只返回error)，其他关于Create、Update、Delete操作只需要传递值即可(如果不需要数据段Create和Update的时间信息)，项目中尽量减少指针传递的操作，避免频繁的内存逃逸增加Go的GC压力</del></p><p>最开始以为传入指针就会发生内存逃逸，后面发现并不是，具体请查看 <a href="https://snowyangyuxin.github.io/2021/07/30/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/">Go逃逸分析详解</a></p></li><li><p>只有对于Find操作时需要传递指针的(因为要获取数据)，其他关于Create、Update、Delete操作只需要传递值即可(如果不需要数据段Create和Update的时间信息)，但是对于传值还是传指针，需要根据具体实际看(对于多字段的传值会有更多的<code>copy</code>操作)</p></li></ul><h1 id="Control层标准化"><a href="#Control层标准化" class="headerlink" title="Control层标准化"></a>Control层标准化</h1><ul><li>函数传递的值能少也要尽量少(前提是满足需求)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindXxx</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> article model<br>    ...<br>    <span class="hljs-keyword">if</span> err:=DBxxxOperate(article.ID,article.Tag,&amp;article);err!=<span class="hljs-literal">nil</span>&#123;<br>        <br>    &#125;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DBxxxFind</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>,tag <span class="hljs-keyword">string</span>,article *model)</span><span class="hljs-title">error</span></span>&#123;<br>    <span class="hljs-keyword">return</span> DB.Where(<span class="hljs-string">&quot;id=? AND type=?&quot;</span>,id,tag).Find(&amp;article).Error  <br>&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindXxx</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> article model<br>    ...<br>    <span class="hljs-keyword">if</span> err:=DBxxxOperate(&amp;article);err!=<span class="hljs-literal">nil</span>&#123;<br>        <br>    &#125;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DBxxxFind</span><span class="hljs-params">(article *model)</span><span class="hljs-title">error</span></span>&#123;<br>    <span class="hljs-keyword">return</span> DB.Where(<span class="hljs-string">&quot;id=? AND type=?&quot;</span>,atricle.ID,article,Tag).Find(&amp;article).Error  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要相信一个原则：<strong>永远不要相信前端给你传来的值</strong>，则对于前端传来的值都需要进行验证，比如delete时需要验证delete_id是否存在，因为就算不存在delete空也不会报错，而对于update更要验证update_id的存在，因为<strong>不存在的话update会在数据库创建一个update_id的对象</strong></li></ul><h1 id="Error返回标准化"><a href="#Error返回标准化" class="headerlink" title="Error返回标准化"></a>Error返回标准化</h1><p>对于API接口的调用返回也是非常重要的，对于返回最要使用同一的结构体进行封装(这样也是为了前端姿势同一和在进行测试时便利)</p><p>采用<code>Code</code>和<code>Data</code>的组合，<del>没有加入消息<code>Message</code></del>和错误<code>Error</code>，<strong>因为对于发生错误时是并不需要前端和客户端知道具体是什么错误</strong>，只需要知道错误码，而后端则可以通过错误码来查看具体api逻辑值错误的地方，而消息Message则可以写在日志中，需要时则进行查看</p><p><strong>更新：现在需要加入消息msg，因为这样前端在测试时才知道是自己出现了问题还是后端的问题</strong></p><p>因为只要是有相应，则说明客户端和服务器相应成功，都应该是返回200，所以设置新的错误码才能有利于去区分不同的错误类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Response <span class="hljs-keyword">struct</span> &#123;<br>   Code ErrCode     <span class="hljs-string">`json:&quot;code,omitempty&quot;`</span><br>   Msg  <span class="hljs-keyword">string</span>      <span class="hljs-string">`json:&quot;msg&quot;`</span><br>   Data <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:&quot;data,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ErrCode <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">const</span> Success ErrCode = <span class="hljs-number">20000</span><br><br><span class="hljs-keyword">const</span> (<br>ErrService                ErrCode = <span class="hljs-number">1000</span><br>ErrBindJson                       = <span class="hljs-number">1001</span><br>    ...<br>)<br></code></pre></td></tr></table></figure><p>​    </p><p>对返回进行进一步封装，可分为成功有返回、成功无返回、错误(是为了在<code>control</code>层写时清晰，知道是哪一种返回类型)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResSuccessData</span><span class="hljs-params">(c *gin.Context, data <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>   ResJson(c, Response&#123;Code: SuccessCode, Data: data&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResSuccess</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>   ResJson(c, Response&#123;Code: SuccessCode&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResErr</span><span class="hljs-params">(c *gin.Context, code ErrCode)</span></span> &#123;<br>   ResJson(c, Response&#123;Code: code&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResJson</span><span class="hljs-params">(c *gin.Context, data <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>   c.JSON(http.StatusOK, data)<br>   c.Abort()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在平时或工作中需要对自己代码进行严格的把控，对需要标准化的地方要仔细，这样才能写出高质量的代码</p><p>但是并不是在任何时候都要对代码标准化严格执行，在实际生产中，代码是需要在规定的时间进行产出，如果在任何时候任何地点严格把控代码就会大大拖慢项目进度</p><p>例如在error返回标准化时在项目最初是不需要对错误码进行规范等</p><p>但是在err优化操作、大小写字母命名这样的习惯则需要在任何时候养成</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用yml文件生成SwaggerAPI接口文档</title>
    <link href="/2021/10/15/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/"/>
    <url>/2021/10/15/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在，在程序开发中前后端分离的模式已经成了主流，而在前后端分离的项目中，如果后端的开发人员能提供一份清晰明了的接口文档，那么对接的前端开发人员也会轻松很多，<strong>大大的提高了前后端沟通效率和开发速度</strong></p><p><code>Swagger</code>可以用来定义和记录<code>RESTful Web</code>服务的接口文档，可以通过<strong>使用给接口代码添加申明式注释的方式</strong>、也可以<strong>使用yml文档格式</strong>来生成swagger渲染的前端接口文档界面</p><p>下面来介绍第二种：使用<code>yml</code>文档格式的方式来生成<code>swagger</code>渲染接口文档，用的是<strong>OpenAPI 3</strong>的标准</p><h1 id="yml文档规则"><a href="#yml文档规则" class="headerlink" title="yml文档规则"></a>yml文档规则</h1><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">openapi:</span> <span class="hljs-number">3.0</span><span class="hljs-number">.0</span> <span class="hljs-comment">#必填字段 指定swagger版本号</span><br><span class="hljs-attr">info:</span><br>  <span class="hljs-attr">description:</span> <span class="hljs-string">接口文档的总描述#接口文档描述</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;1.1.0&quot;</span> <span class="hljs-comment">#文档版本</span><br>  <span class="hljs-attr">title:</span> <span class="hljs-string">test</span> <span class="hljs-string">服务</span> <span class="hljs-comment">#接口文档标题</span><br>  <span class="hljs-attr">contact:</span><br>    <span class="hljs-attr">email:</span> <span class="hljs-string">xxx@xxx.com</span> <span class="hljs-comment">#联系邮箱</span><br><span class="hljs-attr">servers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">description:</span> <span class="hljs-string">这是接口文档的IP端口地址</span> <span class="hljs-comment">#地址的描述</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">http://127.0.0.1:8080/</span> <span class="hljs-comment">#接口的IP端口地址</span><br><span class="hljs-attr">tags:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">服务接口组1</span><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">这是接口组1的注释</span> <span class="hljs-comment">#给下面有相应标签的接口添加注释</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">用户</span><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">这是接口用户组的注释</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/image-20210827100343400.png" alt="image-20210827100343400"></p><p>​    </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">paths:</span> <br>  <span class="hljs-string">/service-test/v1/login:</span><br>    <span class="hljs-attr">post:</span> <span class="hljs-comment">#必填字段,定义HTTP操作方法，必须是http协议定义的方法</span><br>      <span class="hljs-attr">tags:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">用户</span> <span class="hljs-comment">#能通过上面tag desc添加标签注释</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">用户登录</span> <span class="hljs-comment">#接口描述</span><br>      <span class="hljs-attr">parameters:</span> <span class="hljs-comment">#参数</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SECRET_CODE</span><br>          <span class="hljs-attr">in:</span> <span class="hljs-string">header</span> <span class="hljs-comment">#参数参数的地方，可填header、path、query</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">用户鉴权码</span><br>          <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#是否必填</span><br>          <span class="hljs-attr">schema:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#参数类型 可选的类型还有array、object、integer、string、boolean</span><br>      <span class="hljs-attr">requestBody:</span> <span class="hljs-comment">#请求结构体(如果有才写)</span><br>        <span class="hljs-attr">content:</span><br>          <span class="hljs-attr">application/json:</span> <span class="hljs-comment">#指定类型为json格式</span><br>            <span class="hljs-attr">schema:</span><br>              <span class="hljs-attr">type:</span> <span class="hljs-string">object</span> <br>              <span class="hljs-attr">example:</span> <span class="hljs-comment">#给出例子</span><br>                &#123;<br>                  <span class="hljs-string">&quot;phone&quot;</span><span class="hljs-string">:&quot;12345678910&quot;</span>,<br>                  <span class="hljs-string">&quot;password&quot;</span><span class="hljs-string">:&quot;123456&quot;</span><br>                &#125;<br>      <span class="hljs-attr">responses:</span> <span class="hljs-comment">#返回值(必要)</span><br>        <span class="hljs-attr">&#x27;200&#x27;:</span> <span class="hljs-comment">#返回成功</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">successful</span> <span class="hljs-string">operation</span><br>          <span class="hljs-attr">content:</span><br>            <span class="hljs-attr">application/json:</span><br>              <span class="hljs-attr">schema:</span><br>                <span class="hljs-attr">type:</span> <span class="hljs-string">object</span><br>                <span class="hljs-attr">example:</span><br>                  &#123;<br>                    <span class="hljs-string">&quot;code&quot;</span><span class="hljs-string">:20000</span>,<br>                    <span class="hljs-string">&quot;msg&quot;</span><span class="hljs-string">:&quot;user</span> <span class="hljs-string">login</span> <span class="hljs-string">success&quot;</span>,<br>                    <span class="hljs-string">&quot;token&quot;</span><span class="hljs-string">:&quot;qwertyuiop&quot;</span><br>                  &#125;<br>        <span class="hljs-attr">&#x27;404&#x27;:</span> <span class="hljs-comment">#返回404失败</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">page</span> <span class="hljs-string">not</span> <span class="hljs-string">found</span> <br></code></pre></td></tr></table></figure><p><img src="/img/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/image-20210827102721799.png" alt="image-20210827102721799"></p><p>​    </p><p><strong>另一种参数方式</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">paths:</span><br>  <span class="hljs-string">/service-test/v1/get_self_info:</span><br>    <span class="hljs-attr">get:</span><br>      <span class="hljs-attr">tags:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">用户</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">获取用户个人信息</span><br>      <span class="hljs-attr">parameters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">token</span><br>          <span class="hljs-attr">in:</span> <span class="hljs-string">header</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">token</span><br>          <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">schema:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">responses:</span><br>        <span class="hljs-attr">&#x27;200&#x27;:</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">successful</span> <span class="hljs-string">operation</span><br>          <span class="hljs-attr">content:</span><br>            <span class="hljs-attr">application/json:</span><br>              <span class="hljs-attr">schema:</span><br>                <span class="hljs-string">$ref:</span> <span class="hljs-string">&#x27;#/components/schemas/Info&#x27;</span> <span class="hljs-comment">#引用在definitions下定义的Info</span><br>        <span class="hljs-attr">&#x27;default&#x27;:</span> <span class="hljs-comment">#执行出错的处理</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">请求失败</span><br>        <br><span class="hljs-attr">components:</span><br>  <span class="hljs-attr">schemas:</span><br>    <span class="hljs-attr">Info:</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>  <span class="hljs-comment">#值类型</span><br>      <span class="hljs-attr">properties:</span> <span class="hljs-comment">#定义属性</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-comment">#属性名</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">integer</span><br>          <span class="hljs-attr">format:</span> <span class="hljs-string">int64</span><br>        <span class="hljs-attr">username:</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">age:</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">integer</span><br>          <span class="hljs-attr">format:</span> <span class="hljs-string">int64</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/image-20210827112512970.png" alt="image-20210827112512970"></p><p><img src="/img/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/image-20210827112706658.png" alt="image-20210827112706658"></p><h1 id="开启Swagger"><a href="#开启Swagger" class="headerlink" title="开启Swagger"></a>开启Swagger</h1><p><strong>安装本地Swagger editor</strong></p><p>在 <a href="https://swagger.io/">https://swagger.io/</a>  官网上下载安装<code>Swagger editor</code>，解压后从<code>cmd</code>进入该文件解压路径，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm insatll -g <span class="hljs-comment">//使用npm之前需要安装node.js环境</span><br>npm satrt<br></code></pre></td></tr></table></figure><p>执行完后才<code>cmd</code>窗口上就会显示<code>Swagger</code>渲染前端页面的url，在浏览器中输入就可以进入本地<code>Swagger editor</code></p><p>​    </p><p><strong>在线使用Swagger editor</strong></p><p>内容和本地是一样的，有网络的情况下可以使用 <a href="http://editor.swagger.io/">http://editor.swagger.io/</a>  体验在线版</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上诉<code>swagger</code>的<code>yml</code>可以给前端一个简单明了的api接口文档，<strong>能大幅度提升项目整体开发进度</strong></p><p>本文只是使用了<code>yml</code>文档来构建<code>swagger</code>前端渲染文档，除此之外，还可以以通过使用给接口代码添加申明式注释的方式，将放在下次的文章内容中</p>]]></content>
    
    
    
    <tags>
      
      <tag>Swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin中添加限流中间件</title>
    <link href="/2021/10/15/Gin%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2021/10/15/Gin%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="限流概念"><a href="#限流概念" class="headerlink" title="限流概念"></a>限流概念</h1><p>高并发系统三大利器“缓存、降级、限流</p><ul><li>缓存：提升系统访问速度和增大处理容量，为相应业务增加缓存</li><li>降级：当服务器压力剧增时，根据业务策略降级，以释放服务资源保证业务正常</li><li>限流：通过对并发限速，以达到拒绝服务、排队或等待、降价等处理</li></ul><h1 id="限流策略"><a href="#限流策略" class="headerlink" title="限流策略"></a>限流策略</h1><blockquote><p><strong>漏桶限流：每次请求时计算桶流量，超过阈值则降级请求</strong></p></blockquote><p>有一个漏桶，请求来了就像是往漏桶里注入水，桶满了舍弃请求，但是无论来多少次请求，桶都以固定的速度滴水(处理请求)</p><p>因为无论来多少流量是以固定的速度处理请求，<strong>所以不能有效的处理大量突发请求的场景</strong></p><p><img src="/img/Gin%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6/image-20210815095535338.png" alt="image-20210815095535338"></p><p>​    </p><blockquote><p><strong>令牌桶限流：每次请求时从令牌桶里取令牌，取不到则降级请</strong>求</p></blockquote><p>有一个令牌桶，以固定的速率向令牌桶中添加令牌，如果桶满了则丢弃令牌，每次请求来了就向令牌桶中取令牌，取得到就放行处理，令牌不足则拒绝请求</p><p><strong>因为令牌桶在平时处理请求时会保持一个桶中余留很多空闲令牌的状态，则可以处理大量突发请求的场景</strong></p><p><img src="/img/Gin%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6/image-20210815095458830.png" alt="image-20210815095458830"></p><h1 id="限流库的使用"><a href="#限流库的使用" class="headerlink" title="限流库的使用"></a>限流库的使用</h1><p><strong>安装限流库</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/juju/ratelimit<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>创建令牌桶的方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建指定填充速率和容量大小的令牌桶</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBucket</span><span class="hljs-params">(fillInterval time.Duration, capacity <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">Bucket</span></span><br><br><span class="hljs-comment">// 创建指定填充速率、容量大小和每次填充的令牌数的令牌桶</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBucketWithQuantum</span><span class="hljs-params">(fillInterval time.Duration, capacity, quantum <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">Bucket</span></span><br><br><span class="hljs-comment">// 创建填充速度为指定速率和容量大小的令牌桶</span><br><span class="hljs-comment">// NewBucketWithRate(0.1, 200) 表示每秒填充20个令牌</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBucketWithRate</span><span class="hljs-params">(rate <span class="hljs-keyword">float64</span>, capacity <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">Bucket</span></span><br></code></pre></td></tr></table></figure><p>​    </p><p><strong>取出令牌的方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 取token（非阻塞）</span><br><span class="hljs-comment">// 输入取token的数量，返回时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">Take</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">time</span>.<span class="hljs-title">Duration</span></span><br><span class="hljs-comment">// 输入去token的数量，返回移除的令牌数，如果取不到token则返回0</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">TakeAvailable</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">int64</span></span><br><br><span class="hljs-comment">// 最多等maxWait时间取token</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">TakeMaxDuration</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>, maxWait time.Duration)</span> <span class="hljs-params">(time.Duration, <span class="hljs-keyword">bool</span>)</span></span><br><br><span class="hljs-comment">// 取token（阻塞）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">Wait</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">WaitMaxDuration</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>, maxWait time.Duration)</span> <span class="hljs-title">bool</span></span><br></code></pre></td></tr></table></figure><h1 id="Gin中使用限流中间件"><a href="#Gin中使用限流中间件" class="headerlink" title="Gin中使用限流中间件"></a>Gin中使用限流中间件</h1><p>在Gin中可以将限流作为中间件注册到路由中</p><p>既可以将它注册到全局中间件，也可以将它注册到局部的路由组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RateLimiter</span><span class="hljs-params">(fillTime time.Duration, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<br>   <span class="hljs-comment">//指定令牌生产速度和容量</span><br>   bucket := ratelimit.NewBucket(fillTime, <span class="hljs-built_in">cap</span>)<br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>       <span class="hljs-comment">// 取不到令牌则返回0</span><br>      <span class="hljs-keyword">if</span> bucket.TakeAvailable(<span class="hljs-number">1</span>) &lt; <span class="hljs-number">1</span> &#123;<br>         c.JSON(http.StatusOK, <span class="hljs-string">&quot;rate limit...&quot;</span>)<br>         c.Abort()<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      c.Next()<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker快速部署ELK</title>
    <link href="/2021/10/15/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/"/>
    <url>/2021/10/15/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为最近需要部署日志收集系统，而网上部署elk的方式多种多样，参差不齐，在尝试后总结出一种快速有效的部署方法</p><h1 id="ELK简介"><a href="#ELK简介" class="headerlink" title="ELK简介"></a>ELK简介</h1><p>ELK Stack是软件集合<code>Elasticsearch</code>、<code>Logstash</code>、<code>Kibana</code>的简称，由这三个软件及其相关的组件可以打造<strong>大规模日志实时处理系统</strong></p><ul><li><p><strong>Elasticsearch</strong> 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，<strong>主要负责将日志索引并存储起来，方便业务方检索查询</strong></p></li><li><p><strong>Logstash</strong>是一个<strong>日志收集、过滤、转发的中间件</strong>，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理</p></li><li><p><strong>Kibana</strong>是一个可视化工具，主要负责<strong>查询 Elasticsearch 的数据并以可视化的方式展现给业务方</strong>，比如各类饼图、直方图、区域图等</p></li></ul><h1 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h1><p>最好使用<strong>4G内存</strong>和<strong>40G磁盘</strong>的服务器，是在没有可以暂时使用虚拟机进行实验</p><p>​    </p><blockquote><p>创建容器之间的通信网络</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">docker network create docker_elk_test<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>拉取镜像</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">docker</span> pull docker.elastic.co/kibana/kibana:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">docker</span> pull docker.elastic.co/logstash/logstash:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>​    </p><h2 id="部署elasticsearch"><a href="#部署elasticsearch" class="headerlink" title="部署elasticsearch"></a>部署elasticsearch</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">创建配置文件，文件位置可有自己选择<br>mkdir /usr/elk/elastic<br>cd /usr/elk/elastic<br>vim elasticsearch.yml<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cluster.name: &quot;docker-cluster&quot;<br><span class="hljs-meta">#</span><span class="bash">配置elasticsearch远程访问</span><br>network.host: 0.0.0.0<br><span class="hljs-meta">#</span><span class="bash">不允许es根据磁盘情况来分配shard 防止磁盘不够时不能写数据</span><br><span class="hljs-meta">#</span><span class="bash">cluster.routing.allocation.disk.threshold_enabled: <span class="hljs-literal">false</span></span><br><span class="hljs-meta">#</span><span class="bash">磁盘占有率达到99%时将不允许往es写数据，只能读数据 默认95%</span><br><span class="hljs-meta">#</span><span class="bash">cluster.routing.allocation.disk.watermark.flood_stage: 99%</span><br></code></pre></td></tr></table></figure><p>​    </p><p><strong>docker 部署</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -d --name es_test -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -p 9200:9200 -p 9300:9300 -v /usr/elk/elastic/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml --network docker_elk_test -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.3.0<br></code></pre></td></tr></table></figure><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 指定jjvm运行参数 最大最小内存</span><br>-e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms256m -Xmx256m&quot;</span> <br><span class="hljs-meta"># 指定通信网络</span><br>--network docker_elk_test<br><span class="hljs-meta"># 指定单节点部署</span><br>-e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span><br></code></pre></td></tr></table></figure><p>启动后在本机上查看 <strong>localhost:9200</strong> </p><p><img src="/img/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/image-20211015092848637.png" alt="image-20211015092848637"></p><h2 id="部署kibana"><a href="#部署kibana" class="headerlink" title="部署kibana"></a>部署kibana</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /usr/elk/kibana<br>cd /usr/elk/kibana<br>vim kibana.yml<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">server.name: kibana<br><span class="hljs-meta">#</span><span class="bash"> 配置Kibana的远程访问</span><br>server.host: &quot;0.0.0.0&quot;<br><span class="hljs-meta">#</span><span class="bash"> 配置es访问地址</span><br>elasticsearch.hosts: [ &quot;http://xx.xx.xx.xx:9200&quot; ]<br><span class="hljs-meta">#</span><span class="bash"> 汉化界面</span><br>i18n.locale: &quot;zh-CN&quot;<br>xpack.monitoring.ui.container.elasticsearch.enabled: true<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>docker 部署</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -d -p 5601:5601  -v /usr/elk/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml -v /etc/localtime:/etc/localtime -e ELASTICSEARCH_URL=http://xx.xx.xx.xx:9200 --network=docker_elk_test --name kibana_test docker.elastic.co/kibana/kibana:7.3.0<br></code></pre></td></tr></table></figure><p>启动后本机查看 <strong>localhost:5601</strong></p><p><img src="/img/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/image-20211015093911524.png" alt="image-20211015093911524"></p><h2 id="部署logstash"><a href="#部署logstash" class="headerlink" title="部署logstash"></a>部署logstash</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /usr/elk/logstash/config<br>cd /usr/elk/logstash/config<br>vim logstash.yml<br>mkdir /usr/elk/logstash/pipeline<br>cd /usr/elk/logstash/pipeline<br>vim logstash.conf<br></code></pre></td></tr></table></figure><p><strong>logstash.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 配置logstash远程访问</span><br><span class="hljs-attr">http.host:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br><span class="hljs-comment"># 配置es访问地址</span><br><span class="hljs-attr">xpack.monitoring.elasticsearch.hosts:</span> [ <span class="hljs-string">&quot;http://xx.xx.xx.xx:9200&quot;</span> ]<br></code></pre></td></tr></table></figure><p><strong>logstash.conf</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh">input &#123;<br>  file &#123;<br>    <span class="hljs-built_in">type</span> =&gt; <span class="hljs-string">&quot;systemlog-localhost&quot;</span><br>    <span class="hljs-comment">#指定文件采集路径</span><br>    path =&gt; <span class="hljs-string">&quot;/var/log/game/*.log&quot;</span><br>    <span class="hljs-comment">#指定收集json格式</span><br>    codec =&gt; json &#123;<br>       charset =&gt; <span class="hljs-string">&quot;UTF-8&quot;</span><br>    &#125;<br>    <span class="hljs-comment">#开始收集点</span><br>    start_position =&gt; <span class="hljs-string">&quot;beginning&quot;</span><br>    <span class="hljs-comment">#扫描间隔时间，默认是1s，建议5s</span><br>    stat_interval =&gt; <span class="hljs-string">&quot;5&quot;</span><br>  &#125;<br>&#125;<br><br>output &#123;<br>  elasticsearch &#123;<br>    hosts =&gt; [<span class="hljs-string">&quot;xx.xx.xx.xx:9200&quot;</span>]<br>    <span class="hljs-comment"># 指定输出es的index</span><br>    index =&gt; <span class="hljs-string">&quot;game_test&quot;</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>docker部署</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -d --name logstash_test --network=docker_elk_test -p 5000:5000 -v /usr/elk/logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml -v /usr/elk/logstash/pipeline/logstash.conf:/usr/share/logstash/pipeline/logstash.conf -v /usr/log/game:/var/log/game docker.elastic.co/logstash/logstash:7.3.0 <br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 一定要指明收集地址，上面配置文件的路径是容器内部的，一定要建立与外部的数据卷</span><br>-v /usr/<span class="hljs-built_in">log</span>/game:/var/<span class="hljs-built_in">log</span>/game<br></code></pre></td></tr></table></figure><p>现在在文件 <strong>/usr/log/game/xxx.log</strong> 在kibana创建索引index后就可以查看</p><p><img src="/img/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/image-20211015094607601.png" alt="image-20211015094607601"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上文只是<code>elk</code>的初步部署方式</p><p>在<code>logstash</code>中还有很多采集日志的小技巧，特别是<code>grok</code>中的正则</p><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html#plugins-inputs-file-sincedb_path">logstash官网</a> 中可以进一步查看相应内容</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go逃逸分析</title>
    <link href="/2021/10/15/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"/>
    <url>/2021/10/15/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在优化公司之前实习生写的后端代码，在db层这里</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateXxx</span><span class="hljs-params">(xx *model.Xxx)</span> <span class="hljs-title">error</span></span> &#123;<br>   <span class="hljs-keyword">return</span> db.Database.Create(&amp;xx).Error<br>&#125;<br></code></pre></td></tr></table></figure><p>当时觉得只是创建，则不需要传结构体指针，并且觉得传了指针后引起内存逃逸，增加GC压力，后续中总觉得是传指针可能不一定就会引发内存逃逸，则查阅了相关资料和自己之前做的笔记，对此情况做一个详细的说明</p><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><p>Go有两个地方可以分配内存：一个全局堆空间用来<strong>动态分配内存</strong> (<strong>new  make</strong>)，另一个是每个goroutine都有的自身栈空间(<strong>初始是2k</strong>)</p><p><img src="/img/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/image-20210801171749935.png" alt="image-20210801171749935"></p><blockquote><p>栈</p></blockquote><p>栈区内存一般由<strong>编译器自动进行分配和释放</strong>，其中存储着函数的入参以及局部变量，这些参数会<strong>随着函数的创建而创建，函数的返回而销毁</strong>（通过<code>CPU push &amp; release</code> ）</p><p>​    </p><blockquote><p>堆</p></blockquote><p>堆区的内存一般由<strong>编译器和工程师自己共同进行管理分配</strong>，交给 <strong>Runtime GC</strong> 来释放。堆上分配必须找到一块足够大的内存来存放新的变量数据。后续释放时，垃圾回收器扫描空间寻找不再被使用的对象</p><p>任何时候一个值出了一个函数的作用域，它就会被自动分配到堆上 (<strong>由编译器分析</strong>出来是否有<strong>逃逸行为</strong>)</p><p>​    </p><p><strong>栈分配廉价，堆分配昂贵</strong></p><p>Go声明语法并没有提到栈和堆，而是交给GO编译器决定在哪分配内存，保证程序的正确性</p><h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>通过检查变量的作用域是否超出它所在的栈来决定是否将它分配在堆上的技术，其中<strong>变量的作用域超出它所在的栈这种行为即被称为逃逸</strong>。逃逸分析在大多数语言里属于静态分析：在编译期由静态代码分析来决定一个值是否能被分配在栈帧上，还是需要逃逸到堆上</p><ul><li>减少GC压力，栈的变量，随着函数退出后系统直接回收，不需要标记后清除</li><li>减少内存碎片的产生</li><li>减轻分配堆内存的开销，提高程序的运行速度</li></ul><p>​    </p><p>Go语言虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的</p><ul><li>逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析</li><li>如果变量在函数外部没有引用，则优先放到栈中</li><li>如果变量在函数<strong>外部存在引用</strong>，则<strong>必定放在堆中</strong></li></ul><p>​    </p><p>可以通过 <code>go build -gcflags -m xxx.go</code> 命令来查看逃逸分析结果，其中<code>-m </code>打印逃逸分析信息</p><h1 id="逃逸案例"><a href="#逃逸案例" class="headerlink" title="逃逸案例"></a>逃逸案例</h1><blockquote><p>变量类型不确定</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">666</span><br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>fmt.Println</code>的函数参数为<code>interface</code>类型，编译期不能确定其参数的具体类型，所以将其分配于堆上</p><p>​    </p><blockquote><p>暴露给外部指针</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> *<span class="hljs-title">int</span></span> &#123;<br>a := <span class="hljs-number">666</span><br><span class="hljs-keyword">return</span> &amp;a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num *<span class="hljs-keyword">int</span><br>num= foo()<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>变量所占内存较大</p></blockquote><p>Go中常说的<code>goroutine</code>初始大小为<code>2KB</code>，就是指用户栈，而堆则会大很多，所以，为了不造成栈溢出和频繁的扩缩容，<strong>大的对象分配在堆上更加合理</strong></p><p>​    </p><blockquote><p>变量大小不确定</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-number">1</span><br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>s[i] = i<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>foo()<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>make</code>方法中，没有直接指定大小，而是填入了变量<code>n</code>，这时Go逃逸分析也会将其分配到堆区去。可见，为了保证内存的绝对安全，Go的编译器可能会将一些变量不合时宜地分配到堆上</p><p>​    </p><blockquote><p>发送指针或带有指针的值到channel中</p></blockquote><p>在编译时，是没有办法知道哪个 <code>goroutine</code> 会在 <code>channel</code> 上接收数据。所以编译器没法知道变量什么时候才会被释放</p><p>​    </p><blockquote><p>在一个切片上存储或带有指针的值</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> s []*Student<br>   s=<span class="hljs-built_in">append</span>(s,&amp;Student&#123;Name: <span class="hljs-string">&quot;ice&quot;</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>一个典型的例子就是 <code>[]*string</code>。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上</p><p>​    </p><blockquote><p>slice背后的数组被重新分配 (地址要改变)</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//发生了逃逸 因为底层数组扩容数组会重新分配</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddNum</span><span class="hljs-params">(a *[]<span class="hljs-keyword">int</span>)</span></span>&#123;<br>   *a=<span class="hljs-built_in">append</span>(*a,<span class="hljs-number">99</span>)<br>&#125;<br><span class="hljs-comment">//没有发生逃逸 因为没有扩容底层数组没有改变</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdateNum</span><span class="hljs-params">(a *[]<span class="hljs-keyword">int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(*a) &gt; <span class="hljs-number">0</span> &#123;<br>(*a)[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考之前 <a href="https://snowyangyuxin.github.io/2021/07/29/Go%E5%88%87%E7%89%87%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/">Go切片在函数中的传递</a>知，在切片作为参数传递时，如果append引发扩容就会<strong>重新分配底层数组的地址</strong></p><p>slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配</p><p>​    </p><blockquote><p>在interface类型上调用方法</p></blockquote><p>在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道</p><p>​    </p><blockquote><p>外部是否发生引用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> global *<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-keyword">int</span><br>x = <span class="hljs-number">1</span><br>global = &amp;x<br>&#125;<br></code></pre></td></tr></table></figure><p>函数里的<code>x</code>变量在堆上分配，因为它在函数退出后依然可以通过<code>global</code>变量找到，虽然它是在函数内部定义的</p><h1 id="指针逃逸的总结"><a href="#指针逃逸的总结" class="headerlink" title="指针逃逸的总结"></a>指针逃逸的总结</h1><blockquote><p>指针必然发生逃逸的三种情况</p></blockquote><ul><li><p>在某个函数中<code>new</code>或字面量创建出的变量，将其指针作为函数返回值，则该变量一定发生逃逸（构造函数返回的指针变量一定逃逸）</p></li><li><p>被已经逃逸的变量引用的指针，一定发生逃逸</p></li><li><p>被指针类型的<code>slice、map和chan</code>引用的指针，一定发生逃逸</p></li></ul><p>​    </p><blockquote><p>指针必然不会逃逸的情况</p></blockquote><ul><li><p>指针被未发生逃逸的变量引用；</p></li><li><p>仅仅在函数内对变量做取址操作，而未将指针传出；</p></li></ul><p>​    </p><blockquote><p>指针有一些情况可能发生逃逸，也可能不会发生逃逸</p></blockquote><ul><li>将指针作为入参传给别的函数；这里还是要看指针在被传入的函数中的处理过程，如果发生了上边的三种情况，则会逃逸；否则不会逃逸</li></ul><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li><p>现在说明在函数传参传指针不应定会发生内存逃逸，要结合实际情况，看函数中是否将参数传入<code>interface</code>参数的函数中等</p></li><li><p>理解逃逸分析一定能帮助写出更好的程序。知道变量分配在栈堆之上的差别，那么我们就要尽量写出分配在栈上的代码，堆上的变量变少了，可以减轻内存分配的开销，减小gc的压力，提高程序的运行速度</p></li><li><p>不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多 (可能会发生逃逸)</p></li><li><p>尽量写出少一些逃逸的代码，提升程序的运行效率</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go调用K8S</title>
    <link href="/2021/09/26/Go_k8s/"/>
    <url>/2021/09/26/Go_k8s/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用Go创建k8s的客户端和k8s API server进行交互是非常简便的，本文将进行简要的讲解</p><h1 id="拉取依赖"><a href="#拉取依赖" class="headerlink" title="拉取依赖"></a>拉取依赖</h1><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">go</span> get k<span class="hljs-number">8</span>s.io/client-go@v<span class="hljs-number">0</span>.<span class="hljs-number">18</span>.<span class="hljs-number">11</span>-rc.<span class="hljs-number">0</span><br><span class="hljs-attribute">go</span> get k<span class="hljs-number">8</span>s.io/api@v<span class="hljs-number">0</span>.<span class="hljs-number">18</span>.<span class="hljs-number">11</span>-rc.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>   server = <span class="hljs-string">&quot;https://127.0.0.1:8080&quot;</span><br>   token  = <span class="hljs-string">&quot;xxxx&quot;</span><br>)<br><span class="hljs-keyword">var</span>(<br>Client *kubernetes.Clientset<br>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitK8sClient</span><span class="hljs-params">()</span> *<span class="hljs-title">kubernetes</span>.<span class="hljs-title">Clientset</span></span> &#123;<br>   tokenBytes, err := base64.StdEncoding.DecodeString(token) <span class="hljs-comment">// 解析token</span><br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;token 解析失败&quot;</span>)<br>   &#125;<br>   config := &amp;rest.Config&#123;<br>      BearerToken: <span class="hljs-keyword">string</span>(tokenBytes), <span class="hljs-comment">// k8s的token</span><br>      Host:        server, <span class="hljs-comment">// k8s的host</span><br>      TLSClientConfig: rest.TLSClientConfig&#123;<br>         Insecure: <span class="hljs-literal">true</span>,<br>      &#125;,<br>   &#125;<br>   <span class="hljs-comment">// 根据指定的 config 创建一个新的 clientSet</span><br>   clientSet, err := kubernetes.NewForConfig(config)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err.Error())<br>   &#125;<br>   <span class="hljs-keyword">return</span> clientSet<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="获取deployment"><a href="#获取deployment" class="headerlink" title="获取deployment"></a>获取deployment</h1><h2 id="使用API获取deployment"><a href="#使用API获取deployment" class="headerlink" title="使用API获取deployment"></a>使用API获取deployment</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取deployment</span><br><span class="hljs-comment">// 指定namespace为test_namespace</span><br>deployments, err := Client.AppsV1().Deployments(<span class="hljs-string">&quot;test_namespace&quot;</span>).List(context.TODO(), meta_v1.ListOptions&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> deployments.Items &#123;<br>   fmt.Println(v.Name)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用informer获取deployment"><a href="#使用informer获取deployment" class="headerlink" title="使用informer获取deployment"></a>使用informer获取deployment</h2><p><strong>informer</strong></p><blockquote><p><strong>为什么使用informer？</strong></p></blockquote><p>使用 Informer 实例的 Lister() 方法， List/Get Kubernetes 中的 Object 时，<strong>Informer 不会去请求 Kubernetes API，而是直接查找缓存在本地内存中的数据(这份数据由 Informer 自己维护)<strong>。通过这种方式，</strong>Informer 既可以更快地返回结果，又能减少对 Kubernetes API 的直接调用</strong>。</p><p>​    </p><blockquote><p><strong>informer的机制</strong></p></blockquote><p>Informer 只会调用 Kubernetes List 和 Watch 两种类型的 API。Informer 在初始化的时，<strong>先调用 Kubernetes List API 获得某种 resource 的全部 Object，缓存在内存中</strong>; 然后，调用 Watch API 去 watch 这种 resource，去维护这份缓存; 最后，Informer 就不再调用 Kubernetes 的任何 API。</p><p>​    </p><blockquote><p><strong>可监听并触发回调函数</strong></p></blockquote><p>Informer 通过 Kubernetes Watch API 监听某种 resource 下的所有事件。而且，Informer 可以添加自定义的<strong>回调函数</strong>，这个回调函数实例(即 <code>ResourceEventHandler</code> 实例)只需实现 <code>OnAdd(obj interface&#123;&#125;)</code>、<code>OnUpdate(oldObj, newObj interface&#123;&#125;)</code>和 <code>OnDelete(obj interface&#123;&#125;)</code> 三个方法，这三个方法分别对应 informer 监听到创建、更新和删除这三种事件类型。</p><p>​    </p><blockquote><p><strong>二级缓存</strong></p></blockquote><p>二级缓存属于 Informer 的底层缓存机制，这两级缓存分别是 <strong>DeltaFIFO</strong> 和 <strong>LocalStore</strong>。</p><p>Delta代表变化， FIFO则是先入先出的队列。DeltaFIFO将接受来的资源event，转化为特定的变化类型，存储在队列中，周期性的POP出去，分发到事件处理器，并更新Indexer中的本地缓存</p><p>这两级缓存的用途各不相同。DeltaFIFO 用来存储 Watch API 返回的各种事件 ，LocalStore 只会被 Lister 的 List/Get 方法访问 。</p><p>虽然 Informer 和 Kubernetes 之间没有 resync 机制，但 Informer 内部的这两级缓存之间存在 resync 机制。</p><p>​    </p><blockquote><p><strong>详细参考资料</strong></p></blockquote><p><a href="https://www.kubernetes.org.cn/2693.html">informer详解1</a></p><p><a href="https://www.cnblogs.com/yangyuliufeng/p/13611126.html">informer详解2</a></p><p>​    </p><p><strong>goalng中使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> DeploymentInformer cache.SharedIndexInformer<br><br>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-comment">//创建factory，第一个参数是与k8s-api-server交互的客户端，第二个参数用于设置多久进行一次resync(周期性的List操作)</span><br>factory := informers.NewSharedInformerFactoryWithOptions(Client, time.Second*<span class="hljs-number">10</span>) <br>DeploymentInformer = factory.Apps().V1().Deployments().Informer() <span class="hljs-comment">// 创建deployment的informer</span><br><br><span class="hljs-comment">//通过informer.Run(stop)运行该informer，它是一个持久化的goroutine，通过client对象与k8s-api-server交互。</span><br><span class="hljs-comment">//chan_stop用于在程序进程退出前通知Informer退出</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>DeploymentInformer.Run(stop) <br>&#125;()<br><br><span class="hljs-comment">//需要先运行informer监听后才能获取列表</span><br>list := DeploymentInformer.GetStore().List()<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> list &#123;<br>deployment := v.(*apps_v1.Deployment)<br>fmt.Println(deployment.Name)<br>&#125;<br><span class="hljs-keyword">select</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="创建deployment"><a href="#创建deployment" class="headerlink" title="创建deployment"></a>创建deployment</h1><p>说明</p><blockquote><p>label</p></blockquote><p>Label是Kubernetes系列中另外一个核心概念。是一组绑定到K8s资源对象上的key/value对。同一个对象的labels属性的key必须唯一。label可以附加到各种资源对象上，如Node,Pod,Service,RC等。</p><p>通过给指定的资源对象捆绑一个或多个不用的label来实现<strong>多维度的资源分组管理功能</strong>，以便于灵活，<strong>方便地进行资源分配，调度，配置，部署等管理工作</strong>。</p><p>示例如下：　</p><ul><li>版本标签：”release” : “stable” , “release” : “canary”…</li><li>环境标签：”environment” : “dev” , “environment” : “production”</li><li>架构标签：”tier” : “frontend” , “tier” : “backend” , “tier” : “middleware”</li><li>分区标签：”partition” : “customerA” , “partition” : “customerB”…</li><li>质量管控标签：”track” : “daily” , “track” : “weekly”</li></ul><p>​    </p><blockquote><p>namespace</p></blockquote><p>​       namespaces是kubernetes集群中的虚拟化集群。在一个Kubernetes集群中可以拥有多个命名空间，<strong>它们在逻辑上彼此隔离</strong>。 他们可以为个人和团队提供组织，安全甚至性能方面的帮助。</p><p>​        命名空间适用于存在很多跨多个团队或项目的用户的场景。对于只有几到几十个用户的集群，根本不需要创建或考虑命名空间。当需要名称空间提供的功能时，请开始使用它们。<br> 命名空间为名称提供了一个范围。资源的名称需要在命名空间内是唯一的，但不能跨命名空间。命名空间不能相互嵌套，<strong>每个 Kubernetes 资源只能在一个命名空间中</strong>。<br>​        命名空间是在<strong>多个用户之间划分集群资源的一种方法</strong>（通过资源配额）。<br>​        在 Kubernetes 未来版本中，相同命名空间中的对象默认将具有相同的访问控制策略。<br>​        不需要使用多个命名空间来分隔轻微不同的资源，例如同一软件的不同版本：<strong>使用 labels来区分同一命名空间中的不同资源</strong>。</p><p>​    </p><blockquote><p>selector</p></blockquote><p>K8S中的Service是一个抽象概念，它定义了一个服务的多个pod逻辑合集和访问pod的策略，一般把service称为微服务</p><p><strong>举个例子：</strong>一个a服务运行3个pod，b服务怎么访问a服务的pod，pod的ip都不是持久化的<strong>重启之后就会有变化</strong>。<br>这时候b服务可以访问跟a服务绑定的service，service信息是固定的提前告诉b就行了，service通过Label Selector跟a服务的pod绑定,无论a的pod如何变化对b来说都是透明的。</p><p>​    </p><blockquote><p>ImagePullPolicy</p></blockquote><ul><li>Allow：总是拉取pull</li><li>ifNotPresent：本地有镜像则优先使用本地</li><li>Never：只是用本地镜像，从不拉取</li></ul><p><strong>代码内书写yaml进行创建</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateDeployment</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    <br>deployment := &amp;apps_v1.Deployment&#123;<br>ObjectMeta: meta_v1.ObjectMeta&#123;<br>Name: <span class="hljs-string">&quot;xxx-name&quot;</span>,<br>&#125;,<br>Spec: apps_v1.DeploymentSpec&#123;<br>Replicas: int32Ptr(<span class="hljs-number">2</span>),<br>Selector: &amp;meta_v1.LabelSelector&#123;<br>MatchLabels: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;app&quot;</span>: <span class="hljs-string">&quot;xxx-name&quot;</span>,<br>&#125;,<br>&#125;,<br>Template: core_v1.PodTemplateSpec&#123;<br>ObjectMeta: meta_v1.ObjectMeta&#123;<br>Labels: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;app&quot;</span>: <span class="hljs-string">&quot;xxx-name&quot;</span>,<br>&#125;,<br>&#125;,<br>Spec: core_v1.PodSpec&#123;<br>Containers: []core_v1.Container&#123;<br>&#123;<br>Name:            <span class="hljs-string">&quot;test-a&quot;</span>,<br>Image:           <span class="hljs-string">&quot;image_a:1.1.0&quot;</span>,<br>ImagePullPolicy: <span class="hljs-string">&quot;IfNotPresent&quot;</span>,<br>Ports: []core_v1.ContainerPort&#123;<br>&#123;<br>Name:          <span class="hljs-string">&quot;http&quot;</span>,<br>Protocol:      core_v1.ProtocolTCP,<br>ContainerPort: <span class="hljs-number">8080</span>,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#123;<br>                            Name:            <span class="hljs-string">&quot;test-b&quot;</span>,<br>Image:           <span class="hljs-string">&quot;image_b:1.1.0&quot;</span>,<br>ImagePullPolicy: <span class="hljs-string">&quot;IfNotPresent&quot;</span>,<br>Ports: []core_v1.ContainerPort&#123;<br>&#123;<br>Name:          <span class="hljs-string">&quot;http&quot;</span>,<br>Protocol:      core_v1.ProtocolTCP,<br>ContainerPort: <span class="hljs-number">8081</span>,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;<br>    <span class="hljs-comment">// 创建deployment</span><br>    <span class="hljs-comment">// 指定namespace为test_namespace</span><br><span class="hljs-keyword">if</span> _, err := Client.AppsV1().Deployments(<span class="hljs-string">&quot;test_namespace&quot;</span>).Create(context.TODO(), deployment, meta_v1.CreateOptions&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">int32Ptr</span><span class="hljs-params">(i <span class="hljs-keyword">int32</span>)</span> *<span class="hljs-title">int32</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;i<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="获取configmap"><a href="#获取configmap" class="headerlink" title="获取configmap"></a>获取configmap</h1><p>ConfigMap是一种API对象，用来将<strong>非加密数据</strong>保存到键值对中。可以用作环境变量、命令行参数或者存储卷中的配置文件。</p><p>ConfigMap可以将环境变量<strong>配置信息和容器镜像解耦</strong>，便于应用配置的修改。如果需要存储加密信息时可以使用Secret对象</p><p><a href="https://liumiaocn.blog.csdn.net/article/details/103818799?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link">k8s中configmap的增删查改</a></p><p>​    </p><p><strong>golang中使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := Client.CoreV1().ConfigMaps(<span class="hljs-string">&quot;namespace_name&quot;</span>).Get(context.TODO(), <span class="hljs-string">&quot;configmap_name&quot;</span>, meta_v1.GetOptions&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> key,value:=<span class="hljs-keyword">range</span> data.Data&#123;<br>fmt.Println(key,<span class="hljs-string">&quot;:&quot;</span>,value)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go使用copier库</title>
    <link href="/2021/09/24/Go_copier%E5%BA%93/"/>
    <url>/2021/09/24/Go_copier%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在重构公司项目的<code>model</code>层，发现在数据库<code>model</code>向返回<code>ack  model</code>之间的结构体转换时，因为<code>model</code>字段多，则存在大量的直接赋值，不美观也不优雅，例如</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(person *Person)</span> <span class="hljs-title">MapTo</span><span class="hljs-params">()</span> <span class="hljs-title">model</span>.<span class="hljs-title">Student</span></span> &#123;<br>    <span class="hljs-keyword">var</span> student model.Student<br>now := time.Now()<br>    student.ID=person.ID<br>    student.Name=persobn.Name<br>    student.Age=persobn.Age<br>    student.Phone=persobn.Phone<br>    student.Address=persobn.Address<br>    student.Gender=persobn.Gender<br>    student.ParentPhone=persobn.ParentPhone<br>    student.Mother=persobn.Mother<br>    student.Father=persobn.Father<br>    student.Socre=<span class="hljs-number">100</span><br><span class="hljs-keyword">return</span> studnet<br>&#125;<br></code></pre></td></tr></table></figure><p>而使用Go的copier库可以<strong>完成不同类型结构体相同字段的赋值</strong>，并且还可以<strong>完成不同字段的赋值</strong>，下面将进行简单的演示</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/jinzhu/copier<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><blockquote><p><strong>字段名相同，类型相同</strong></p></blockquote><p>对于不同类型的结构体，如果字段名相同且字段类型相同，那么<code>copier</code>就会对该字段直接赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>   ID      <span class="hljs-keyword">int</span><br>   Name    <span class="hljs-keyword">string</span><br>   Age     <span class="hljs-keyword">int</span><br>   Address <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>   ID      <span class="hljs-keyword">int</span><br>   Name    <span class="hljs-keyword">string</span><br>   Age     <span class="hljs-keyword">int</span><br>   Address <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   person := Person&#123;<br>      ID:      <span class="hljs-number">1</span>,<br>      Name:    <span class="hljs-string">&quot;snow&quot;</span>,<br>      Age:     <span class="hljs-number">22</span>,<br>      Address: <span class="hljs-string">&quot;China&quot;</span>,<br>   &#125;<br>   <span class="hljs-keyword">var</span> student Student<br>   copier.Copy(&amp;student, &amp;person)<br>   fmt.Println(student)<br>&#125;<br><span class="hljs-comment">//&#123;1 snow 22 China&#125;</span><br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p><strong>字段名相同，类型不同</strong></p></blockquote><p>对于这种情况<code>copie</code>r是不会赋值的，则需要自己手动配置 (所以在model 和 ack间尽量不要设置字段名相同而类型不同)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>   ID      <span class="hljs-keyword">int</span><br>   Name    <span class="hljs-keyword">string</span><br>   Age     <span class="hljs-keyword">int</span><br>   Parent  []<span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>   ID     <span class="hljs-keyword">int</span><br>   Name   <span class="hljs-keyword">string</span><br>   Age    <span class="hljs-keyword">int</span><br>   Parent <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   person := Person&#123;<br>      ID:      <span class="hljs-number">1</span>,<br>      Name:    <span class="hljs-string">&quot;snow&quot;</span>,<br>      Age:     <span class="hljs-number">22</span>,<br>      Parent:  []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;mother&quot;</span>, <span class="hljs-string">&quot;father&quot;</span>&#125;,<br>   &#125;<br>   <span class="hljs-keyword">var</span> student Student<br>   copier.Copy(&amp;student, &amp;person)<br>   student.Parent=strings.Join(person.Parent,<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment">//这里需要手动配置</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p><strong>目标对象中出现不同字段名，但与源对象字段相关</strong></p></blockquote><p>有时候源对象某个字段没有出现在目标对象中，但是目标对象可以使用一个相同字段名的方法，方法接收相同类型的参数，这样在<code>copier</code> <code>Copy</code>时会以源对象的这个字段作为参数调用目标对象的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>   ID     <span class="hljs-keyword">int</span><br>   Name   <span class="hljs-keyword">string</span><br>   Age    <span class="hljs-keyword">int</span><br>   Nation <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>   ID      <span class="hljs-keyword">int</span><br>   Name    <span class="hljs-keyword">string</span><br>   Age     <span class="hljs-keyword">int</span><br>   Address <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(student *Student)</span> <span class="hljs-title">Nation</span><span class="hljs-params">(nat <span class="hljs-keyword">string</span>)</span></span> &#123; <span class="hljs-comment">//以源对象字段名相同的目标对象方法</span><br>   student.Address=nat+<span class="hljs-string">&quot;BeiJin&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   person := Person&#123;<br>      ID:     <span class="hljs-number">1</span>,<br>      Name:   <span class="hljs-string">&quot;snow&quot;</span>,<br>      Age:    <span class="hljs-number">22</span>,<br>      Nation: <span class="hljs-string">&quot;China&quot;</span>,<br>   &#125;<br>   <span class="hljs-keyword">var</span> student Student<br>   copier.Copy(&amp;student, &amp;person)<br>   fmt.Println(student)<br>&#125;<br><span class="hljs-comment">//&#123;1 snow 22 ChinaBeiJin&#125;</span><br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>目标对象中出现不同字段名，但与源对象字段无关</p></blockquote><p>对于这种情况就和<strong>字段名相同类型不同</strong>的方法一样，需要对这个字段单独处理</p><p>​    </p><blockquote><p>不同类型切片的赋值</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   persons := []Person&#123;<br>      &#123;ID: <span class="hljs-number">1</span>, Name: <span class="hljs-string">&quot;snow&quot;</span>,Age: <span class="hljs-number">22</span>&#125;,<br>      &#123;ID: <span class="hljs-number">2</span>, Name: <span class="hljs-string">&quot;ice&quot;</span>,Age: <span class="hljs-number">18</span>&#125;,<br>   &#125;<br>   <span class="hljs-keyword">var</span> students []Student<br>   copier.Copy(&amp;students, &amp;persons)<br>   fmt.Println(students)<br>&#125;<br><span class="hljs-comment">//[&#123;1 snow 22&#125; &#123;2 ice 18&#125;]</span><br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>结构体复制到切片</p></blockquote><p>根据源对象生成一个和目标切片类型相符合的对象，然后<code>append</code>到目标切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   person := Person&#123;<br>      ID:   <span class="hljs-number">1</span>,<br>      Name: <span class="hljs-string">&quot;snow&quot;</span>,<br>      Age:  <span class="hljs-number">22</span>,<br>   &#125;<br>   <span class="hljs-keyword">var</span> students []Student<br>   copier.Copy(&amp;students, &amp;person)<br>   fmt.Println(students)<br>&#125;<br><span class="hljs-comment">//[&#123;1 snow 22&#125;]</span><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://github.com/jinzhu/copier">copier库</a></p><p><code>copier</code>还有很多玩法，本文章值列举了自己在改造时使用过的方法，具体信息可以看官方源码和文档</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go项目场景一</title>
    <link href="/2021/09/24/Go%E9%A1%B9%E7%9B%AE%E5%9C%BA%E6%99%AF%E4%B8%80/"/>
    <url>/2021/09/24/Go%E9%A1%B9%E7%9B%AE%E5%9C%BA%E6%99%AF%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在项目启动后有一个会开一个<code>goroutine</code>，里面有一个<code>chan</code>接收消息数据，如果接收到消息就将数据库的某些配置拉到本地进行配置下发</p><p>之前是设置定时器，每隔一段时间就自动给<code>chan</code>发送消息，现在向进行<strong>实时配置下发</strong>，就是某些API被调用后(对指定数据库消息进行变更的API)将给<code>chan</code>发送消息</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>因为API调用时并发进行的，如果在短时间内有大量的特定API调用，则都会给<code>chan</code>发送消息，而对<code>chan</code>的处理只是单协程，那么之后的请求将会<strong>在<code>chan</code>外堵塞</strong>，可能就达到不了<strong>实时</strong>下发的效果</p><p>对于发送消息，其实<strong>只要后面调用API的<code>goroutine</code>发送的消息即可</strong>，因为后面更新数据库的信息里肯定是包含了前面更新的信息</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><blockquote><p>目前对<code>chan</code>的处理只是单协程，<strong>能不能使用多<code>goroutine</code>去并发竞争<code>chan</code>，提高对<code>chan</code>的处理能力？</strong></p></blockquote><p>不能，因为<code>chan</code>中要更改一个全局<code>map</code>的变量，会加锁，即使使用多<code>goroutine</code>在发送消息给<code>chan</code>后也会进行堵塞</p><p>​    </p><blockquote><p>能不能使用一种机制，就是给发送消息给chan时，看是否有消息在chan外堵塞，有的话则将自己进行替换</p></blockquote><p>因为之后更新的消息肯定是包含前面更新的消息，所以在之前调用API的<code>goroutine</code>和之后调用API的<code>goroutine</code>同时发送消息时，<strong>应该是该舍弃前面的消息保留后面的消息</strong></p><p>原理上是可行的，但实际上操作起来很难，<strong>因为无法获知chan中是否有缓存</strong>，只能取出，并且只能取一个，而且取值操作在<code>chan</code>没有缓存时还会堵塞</p><p>并且还是在每次API调用操作时都会给<code>chan</code>发消息，根本上还是会造成<code>chan</code>的堵塞</p><p>​    </p><blockquote><p>由上面，想是否可以有一种机制，使得不是每次调API用都给<code>chan</code>发送消息，而是满足一定条件才会给<code>chan</code>发送消息</p></blockquote><p>这样可以根本解决<code>chan</code>堵塞的问题，<strong>只要在每次发送前短暂的等待一会</strong>，<strong>看是否有新的<code>goroutine</code>要发送消息，如果要则抛弃本次的消息发送</strong></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>定义实时配置下发的全局变量和结构体</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> realtimeMachine *RealTimeMachine<br><span class="hljs-keyword">type</span> RealTimeMachine <span class="hljs-keyword">struct</span> &#123;<br>   Random <span class="hljs-keyword">int64</span> <span class="hljs-comment">//生成随机数</span><br>   Num    <span class="hljs-keyword">int</span>   <span class="hljs-comment">//强制下发触发次数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>思路：<strong>每次发送前随机生成64位的int数赋值给实时配置下发器的变量，然后设置一个短暂的等待时间，时间后看该变量是否发生改变，如果发生改变则放弃给chan发送消息，如果没有改变则给chan发送消息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImmediatelyUpdateApi</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      xxxApi.ImmediatelyUpdateApi(loader, realtimeMachine, rand.Int63()) <span class="hljs-comment">//随机生成64位int数</span><br>   &#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(xxxApi *xxxApixxx)</span> <span class="hljs-title">ImmediatelyUpdateApi</span><span class="hljs-params">(loader Loader, machine *translate.RealTimeMachine, random <span class="hljs-keyword">int64</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := xxxApi.Translate(loader); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//去数据库更新配置到本地变量</span><br>logger.Warn(<span class="hljs-string">&quot;timed get api is null&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> !xxxApi.CompareDiff() &#123; <span class="hljs-comment">//如果更新后本地变量没有发生变化，则不需要发送消息给chan了</span><br><span class="hljs-keyword">return</span><br>&#125;<br>machine.Random = random<br>machine.Num++<br><span class="hljs-comment">//虽然可能因为多次并发而达不到每十次强制触发一次，但是只要有运行多次强制触发一次的机制即可</span><br><span class="hljs-keyword">if</span> machine.Num == <span class="hljs-number">10</span> &#123;<br>machine.Num = <span class="hljs-number">0</span><br>xxxApi.Chan &lt;- <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">//设置等待更新时间，时间内如果没有发生更改(没有新的goroutine发送消息)则发送消息</span><br>time.Sleep(time.Millisecond * <span class="hljs-number">300</span>)<br><span class="hljs-keyword">if</span> machine.Random == random &#123;<br>xxxApi.Ch &lt;- <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">//如果发生更改则放弃本次消息发送</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p>上面有一个计数强制发送的机制，是因为避免这种情况发生：</p><p>加入设置的是等待时间300ms，如果每300ms内都有新goroutine发送，那么就会一直放弃本次消息发送，迟迟无法更新配置信息</p><p>那么就需要设置一个<strong>强制发送的机制</strong>，就是累计指定次数，就必须发送消息一次，这样就会闭上上诉情况</p><p><del><strong>虽然可能因为多次并发而达不到指定次数强制触发一次(如果要则需要上锁，那么就会影响性能)，但是只要有运行多次强制触发一次的机制即可</strong></del></p><p><strong>下面进行了优化更新！</strong></p><h1 id="优化解决"><a href="#优化解决" class="headerlink" title="优化解决"></a>优化解决</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> realtimeMachine *RealTimeMachine<br><span class="hljs-keyword">type</span> RealTimeMachine <span class="hljs-keyword">struct</span> &#123;<br>   Random <span class="hljs-keyword">int64</span> <span class="hljs-comment">//生成随机数</span><br>   Tiem   <span class="hljs-keyword">int64</span> <span class="hljs-comment">//记录最大超时时间</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>对野生goroutine进行兜底保护</strong></p><p>因为<code>gin</code>框架已经对每一个接口进行了兜底保护，即使发送panic也不会宕机(<code>panic</code>),但是如果在接口中使用了<strong>野生goroutine并且在里面发升了<code>panic</code>，那么整个程序都会崩溃！(包括主程序)</strong></p></li><li><p>使用最大超时时间代替强制发送次数机制，避免了<strong>因多次并发而达不到指定次数强制触发一次</strong>，使得发送时间更加平滑</p></li><li><p><strong>最小等待时间应该大于chan接收信息后函数处理的平均时间</strong></p><p>如果小于，则等待后的时间差还是可能最造成chan阻塞(比如处理10ms，等待2ms，那么如果每3ms发送一次信息，那么每次都会按时发送不会被丢弃并且也会阻塞在chan外(内部用了锁))</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImmediatelyUpdateApi</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <br>       <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//兜底保护</span><br>           <span class="hljs-keyword">if</span> err:=<span class="hljs-built_in">recover</span>();err!=<span class="hljs-literal">nil</span>&#123;<br>               logger(<span class="hljs-string">&quot;happen panic!&quot;</span>)<br>           &#125;<br>       &#125;<br>       xxxApi.ImmediatelyUpdateApi(loader, realtimeMachine, rand.Int63()) <span class="hljs-comment">//随机生成64位int数</span><br>   &#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(xxxApi *xxxApixxx)</span> <span class="hljs-title">ImmediatelyUpdateApi</span><span class="hljs-params">(loader Loader, machine *translate.RealTimeMachine, random <span class="hljs-keyword">int64</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := xxxApi.Translate(loader); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//去数据库更新配置到本地变量</span><br>logger.Warn(<span class="hljs-string">&quot;timed get api is null&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> !xxxApi.CompareDiff() &#123; <span class="hljs-comment">//如果更新后本地变量没有发生变化，则不需要发送消息给chan了</span><br><span class="hljs-keyword">return</span><br>&#125;<br>machine.Random = random<br>now := time.Now().Unix()<br><span class="hljs-keyword">if</span> now-machine.Time &lt; <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//设置最大超时时间，每隔1s的请求都会强制发送</span><br>machine.Time = now<br>envoyRemoteApi.Ch &lt;- <span class="hljs-string">&quot;envoy&quot;</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">//设置最小等待更新时间，时间内如果没有发生更改(没有新的goroutine发送消息)则发送消息</span><br>time.Sleep(time.Millisecond * <span class="hljs-number">300</span>) <span class="hljs-comment">//最小等待时间应该大于发送消息后函数的处理时间</span><br><span class="hljs-keyword">if</span> machine.Random == random &#123;<br>xxxApi.Ch &lt;- <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">//如果发生更改则放弃本次消息发送</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go实现防重放攻击</title>
    <link href="/2021/09/10/Go%E5%AE%9E%E7%8E%B0%E9%98%B2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"/>
    <url>/2021/09/10/Go%E5%AE%9E%E7%8E%B0%E9%98%B2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h1><p>API重放攻击（Replay Attacks）又称重播攻击、回放攻击。他的原理就是把<strong>之前窃听到的数据原封不动的重新发送给接收方</strong>。<strong>HTTPS并不能防止这种攻击</strong>，虽然传输的数据是经过加密的，窃听者无法得到数据的准确定义，但是可以从请求的接收方地址分析出这些数据的作用。</p><p>比如用户登录请求时攻击者虽然无法窃听密码，但是却可以截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。</p><p>比如给自己账号充值1000元，如果能窃听到这个命令并进行不停重放发送给服务器，那么自己账户上的金额将不停增加</p><p>首先要明确一个事情，<strong>重放攻击是二次请求</strong>，黑客通过抓包获取到了请求的HTTP报文，然后黑客自己编写了一个类似的HTTP请求，发送给服务器。也就是说服务器处理了两个请求，<strong>先处理了正常的HTTP请求，然后又处理了黑客发送的篡改过的HTTP请求</strong></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote><p>根据时间戳的方案</p></blockquote><p>每次HTTP请求，都需要<strong>加上timestamp参数</strong>，然后把timestamp和其他参数加密到token里。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间相比较，<strong>是否超过了60s，如果超过了则认为是非法的请求</strong></p><p>​    </p><p>一般情况下，<strong>黑客从抓包重放请求耗时远远超过了60s</strong>，所以此时请求中的stime参数已经失效了。 </p><p>​    </p><p>但这种方式的漏洞也是显而易见的，如果在60s之内进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效</p><p>​    </p><blockquote><p>基于应答式的方案</p></blockquote><p>每次请求前，会先去服务器会根据时间戳获取一个随机数，服务器就会将随机数放在缓存中，在请求时参数带上随机数，将随机数加密在token里，服务器就会校验缓存中是否有随机数，有的话就通过并且删除随机数，没有则认为是非法请求。</p><p>并且服务器缓存的<strong>随机数设置一个60秒的存活时间</strong>，防止客户端拿到随机数后不进行后续操作导致随机数在缓存无法被清除而累积的问题    </p><h1 id="Go实现防重放攻击"><a href="#Go实现防重放攻击" class="headerlink" title="Go实现防重放攻击"></a>Go实现防重放攻击</h1><p>使用<strong>基于应答式的方案</strong>实现防重放攻击</p><p><strong>获取随机数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PutRandom</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>   value, err := setRandom()<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      c.JSON(<span class="hljs-number">400</span>,fmt.Sprintf(<span class="hljs-string">&quot;redis set random err:%v&quot;</span>, err))<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   c.JSON(<span class="hljs-number">200</span>, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setRandom</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br>rand.Seed(time.Now().UnixNano()) <span class="hljs-comment">// 设置纳秒级别的随机数</span><br>random := rand.Intn(math.MaxInt32)<br>str := strconv.Itoa(random)<br><span class="hljs-keyword">if</span> _, err := Redis.Set(str, <span class="hljs-string">&quot;true&quot;</span>, time.Second*<span class="hljs-number">60</span>).Result(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 设置随机数存活时间为60s</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> str, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>校验随机数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckRandom</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>   v := c.GetHeader(<span class="hljs-string">&quot;random&quot;</span>) <span class="hljs-comment">// 也可以存在token里</span><br>   <span class="hljs-keyword">if</span> err := checkRandom(v); err != <span class="hljs-literal">nil</span> &#123;<br>      c.JSON(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;random verify fail&quot;</span>) <span class="hljs-comment">// 检验失败</span><br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   c.JSON(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;random verify success&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkRandom</span><span class="hljs-params">(val <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> _, err := Redis.Get(val).Result(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err <span class="hljs-comment">// 没有查到随机数则返回失败</span><br>&#125;<br>client.Del(val) <span class="hljs-comment">// 检验成功后删除随机数，防止重放攻击</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go安装和使用Redis</title>
    <link href="/2021/09/03/Go_Redis/"/>
    <url>/2021/09/03/Go_Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-安装-Redis"><a href="#Docker-安装-Redis" class="headerlink" title="Docker 安装 Redis"></a>Docker 安装 Redis</h1><blockquote><p>创建data文件做数据持久化存储时</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">mkdir /data/redis<br>mkdir /data/redis/data <br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>做redis容器启动后的配置文件</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">touch /data/redis/redis.conf<br></code></pre></td></tr></table></figure><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># Redis默认不是以守护进程的方式运行</span><br>daemonize no<br><br><span class="hljs-meta"># 指定Redis监听端口，默认端口为6379</span><br>port <span class="hljs-number">6379</span><br><br><span class="hljs-meta"># 绑定的主机地址，不要绑定容器的本地127.0.0.1地址，因为这样就无法在容器外部访问</span><br>bind <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><br><span class="hljs-meta"># 持久化</span><br>appendonly yes<br><br><span class="hljs-meta">#设置密码</span><br>requirepass password  <br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>启动命令</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -p 6379:6379 --name redis -v /docker/redis/redis.conf:/etc/redis/redis.conf -v /docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf<br></code></pre></td></tr></table></figure><p><strong>命令解释</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run redis # 从redis镜像运行容器<br>-p 6379:6379 # 映射本地6379端口到容器6379端口，前为本地端口<br>--name redis # 设置容器名称为redis，方便以后使用docker ps进行管理<br>-v /data/redis/redis.conf:/etc/redis/redis.conf # 关联本地/data/redis/redis.conf文件到容器中/etc/redis/redis.conf，同样，前为本地<br>-v /data/redis/data:/data # 关联本地/docker/redis/data到容器内/data目录，此为存放redis数据的目录，为方便以后升级redis，而数据可以留存<br>-d # 后台启动，使用此方式启动，则redis.conf中daemonize必须设置为no，否则会无法启动<br>redis-server /etc/redis/redis.conf # 在容器内启动redis-server的命令，主要是为了加载配置<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>容器内部使用redis</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it redis_container <span class="hljs-regexp">/bin/</span>sh<br>cd <span class="hljs-regexp">/usr/</span>local/bin<br>redis-cli<br></code></pre></td></tr></table></figure><h1 id="Go-中使用-Redis"><a href="#Go-中使用-Redis" class="headerlink" title="Go 中使用 Redis"></a>Go 中使用 Redis</h1><blockquote><p>安装 go-redis v8</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/<span class="hljs-keyword">go</span>-redis/redis/v8  <br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>初始化 redis client</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> rdb *redis.Client<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitRedisClii</span><span class="hljs-params">(cfg config.RedisConf)</span> <span class="hljs-title">error</span></span> &#123;<br>   rdb = redis.NewClient(&amp;redis.Options&#123;<br>      Addr:     cfg.Address, <br>      Password: cfg.Password, <span class="hljs-comment">//设置好的密码</span><br>      DB:       <span class="hljs-number">0</span>, <span class="hljs-comment">//要连接的redis库</span><br>      PoolSize: <span class="hljs-number">100</span>, <span class="hljs-comment">//连接池的最大连接数</span><br>   &#125;)<br><br>   ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">5</span>*time.Second)<br>   <span class="hljs-keyword">defer</span> cancel()<br>   _, err := rdb.Ping(ctx).Result() <span class="hljs-comment">//检测心跳，确认是否能连接上</span><br>   <span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetRedisCli</span><span class="hljs-params">()</span> *<span class="hljs-title">redis</span>.<span class="hljs-title">Client</span></span> &#123; <br>   <span class="hljs-keyword">return</span> rdb<br>&#125;  <br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>使用 redis</p></blockquote><p>本次以查询评论功能为例</p><p>使用的rpc的调用方式，属于所写的星辰缘项目，是一个微服务架构的项目，在后续中也会逐步完善相关笔记</p><ul><li><p>在使用redis之前要思考为什么使用redis，在什么地方使用redis</p></li><li><p>此次是在查询文章评论功能上使用redis文章评论使用，将db查询结果进行json序列化作为value存入redis（不严谨，目前初始学，暂时先这样），并且设置时间为5s</p></li><li><p>这样每次查就会先去redis中查找是否有相关信息，没有的话再去mysql中找，并且将结果再存入到redis中且设置存活时间为5s</p></li><li><p>这样用户每次新写了评论后可能会5s中后才能看到自己写的评论（不严谨，现在暂时逻辑先这样），虽然<u><strong>造成了延迟，牺牲了及时性</strong></u>，但是却有效<u><strong>保护了mysql</strong></u></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *CommentServer)</span> <span class="hljs-title">QueryComment</span><span class="hljs-params">(ctx context.Context, req *comment.QueryCommentREQ, rsp *comment.QueryCommentRSP)</span> <span class="hljs-title">error</span></span> &#123;<br>   <span class="hljs-keyword">var</span> comments []model.Comment<br>   <span class="hljs-keyword">var</span> ack []*comment.CommentContent<br>   info, err := redisCli.GetRedisCli().Get(ctx, <span class="hljs-string">&quot;comment_id_&quot;</span>+strconv.Itoa(<span class="hljs-keyword">int</span>(req.CommentId))).Bytes() <span class="hljs-comment">//先redis中找数据</span><br>   <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//找到了redis中的数据</span><br>      fmt.Println(<span class="hljs-string">&quot;use redis!&quot;</span>)<br>      err = json.Unmarshal(info, &amp;ack) <span class="hljs-comment">//反序列化</span><br>      rsp.Code = <span class="hljs-keyword">uint32</span>(common.StatusRPCOK)<br>      rsp.Comment = ack<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>   &#125;<br>   err = db.QueryComment(req.CommentId, req.Type, &amp;comments) <span class="hljs-comment">//没有找到就去mysql中查询</span><br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      rsp.Code = <span class="hljs-keyword">uint32</span>(common.ErrRPCCode)<br>      rsp.Err = err.Error()<br>      <span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;db query comment err&quot;</span>)<br>   &#125;<br>   <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> comments &#123;<br>      <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>微服务调微服务优化</span><br>      rspUser, err := client.GetIDUser(v.UserID) <span class="hljs-comment">//去account 微服务中查询user_id的具体信息</span><br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         rsp.Code = <span class="hljs-keyword">uint32</span>(common.ErrRPCCode)<br>         rsp.Err = err.Error()<br>         <span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;db get id user err&quot;</span>)<br>      &#125;<br>      ack = <span class="hljs-built_in">append</span>(ack, &amp;comment.CommentContent&#123;<br>         Id:         v.ID,<br>         CommentId:  v.CommentedID,<br>         Type:       <span class="hljs-keyword">uint32</span>(v.Type),<br>         Content:    v.Content,<br>         Time:       v.Time,<br>         UserId:     v.UserID,<br>         UserAvatar: oss.DownloadUrl(rspUser.Avatar),<br>         UserName:   rspUser.Name,<br>         Love:       <span class="hljs-keyword">int64</span>(v.Love),<br>      &#125;)<br>   &#125;<br>   fmt.Println(<span class="hljs-string">&quot;user mysql!&quot;</span>)<br>   rsp.Code = <span class="hljs-keyword">uint32</span>(common.StatusRPCOK)<br>   rsp.Comment = ack<br>   data, _ := json.Marshal(ack) <span class="hljs-comment">//将查询结果序列化</span><br>    <span class="hljs-comment">//将查询结果存入redis，并设置存活时间为5s</span><br>   err = redisCli.GetRedisCli().Set(ctx, <span class="hljs-string">&quot;comment_id_&quot;</span>+strconv.Itoa(<span class="hljs-keyword">int</span>(req.CommentId)), <span class="hljs-keyword">string</span>(data), time.Second*<span class="hljs-number">5</span>).Err()<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      rsp.Err = <span class="hljs-string">&quot;redis add comment err&quot;</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="贴士"><a href="#贴士" class="headerlink" title="贴士"></a>贴士</h1><p><strong>go-redis中如果Get一个不存在的键会直接返回err</strong>，而不是空字符串</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>星辰缘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Goroutine使用准则</title>
    <link href="/2021/09/03/Goroutine%E4%BD%BF%E7%94%A8%E5%87%86%E5%88%99/"/>
    <url>/2021/09/03/Goroutine%E4%BD%BF%E7%94%A8%E5%87%86%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Gouroutine</code>是Go开发中最常用的功能之一，开启一个Goroutine很简单，但是想要控制一个<code>Goroutine</code>的生命周期却需要一些技巧</p><p>最常见的是<strong>goroutine泄露</strong>问题</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leak</span><span class="hljs-params">()</span></span>&#123;<br>    ch:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>        val:=&lt;-ch<br>        fmt.PrintIn(<span class="hljs-string">&quot;received a value:&quot;</span>,val)<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>函数退出后<code>goroutine</code>并不会退出，而且也不会接收到数据，处于一直被堵塞的状态，并且会占用资源，这就是常见的<code>goroutine</code>泄露(你以为它结束了，其实它没有)</p><h1 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h1><blockquote><p>goroutine最常用的准则</p></blockquote><p><strong>不要开启一个goroutine如果你不知道它什么时候结束</strong></p><p>任何时候开启一个<code>goroutine</code>都要问自己两个问题</p><ul><li>它什么时候结束</li><li>如何让它结束</li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><blockquote><p>设置超时控制</p></blockquote><p>对于一些<code>goroutine</code>应该还要<strong>设置超时控制</strong>，使用<code>context</code></p><p>给<code>goroutine</code>一个超时时间，这样<code>goroutine</code>的结束就在掌握之中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goroutine_1</span><span class="hljs-params">()</span></span> &#123;<br>   ctx, cancel := context.WithTimeout(context.TODO(), <span class="hljs-number">10</span>*time.Second)<br>   <span class="hljs-keyword">defer</span> cancel()<br><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123; <br>      xxx()<br>   &#125;(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>设置recover兜底保护</p></blockquote><p>对于一个我们不知道什么时候会启用的<code>goroutine</code>称为<strong>野生goroutine</strong>（如调用指定接口其业务逻辑会启动一个<code>goroutine</code>）</p><p>在<code>Gin</code>框架中，在我的业务逻辑接口中，即使发生了<code>Panic</code>行为(如数组越界，使用未初始化的map等)也不会使整个程序崩溃，因为在<strong>Gin为每一个调用者都自动启动revover( )进行兜底保护</strong></p><p>但是如果在业务逻辑的接口中又使用了<code>goroutine</code>，并且<strong>在goroutine中发生了Panic行为，那么就会导致整个程序的崩溃</strong></p><p><strong>所以我们对于野生的goroutine要使用recover( )进行兜底保护</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goroutine_2</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <br>      <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>            logger.Errorf(<span class="hljs-string">&quot;happen panic!&quot;</span>)<br>         &#125;<br>      &#125;()<br>       xxx()<br>   &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>使用chan来监听和控制goroutine的生命周期</p></blockquote><p><strong>比如在main函数中同时监听两个端口的正确姿势</strong></p><ul><li>同时监听，平滑退出</li><li>能在main中管理<code>goroutine</code>的生命周期并知道它何时退出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">2</span>)<br>   stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      done &lt;- rpc.GatewayRPC(stop)<br>   &#125;()<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      done &lt;- api.ServiceAPI(stop)<br>   &#125;()<br>    <br>   <span class="hljs-keyword">var</span> stopped <span class="hljs-keyword">bool</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">cap</span>(done); i++ &#123;<br>      <span class="hljs-keyword">if</span> err := &lt;-done; err != <span class="hljs-literal">nil</span> &#123;<br>         fmt.Println(<span class="hljs-string">&quot;err: &quot;</span>, err)<br>      &#125;<br>      <span class="hljs-keyword">if</span> !stopped &#123;<br>         stopped = <span class="hljs-literal">true</span><br>         <span class="hljs-built_in">close</span>(stop)<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用空结构体传递信号(<strong>空结构体不占用内存，用来作为通道的信号传递最好</strong>)</p><p>一旦某个<code>goroutine</code>出现错误就会发送错误信息给done</p><p>done接收到信息后结汇关闭stop，每个有stop通道的<code>goroutine</code>收到信号后就会优雅关闭服务(<code>Shutdown</code>函数)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ServiceAPI</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>   r := router.AgentRouter()<br>   server := &amp;http.Server&#123;<br>      Addr:         <span class="hljs-string">&quot;:8080&quot;</span>,<br>      Handler:      r,<br>   &#125;<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      &lt;-stop<br>      server.Shutdown(context.TODO())<br>   &#125;()<br>   <span class="hljs-keyword">return</span> server.ListenAndServe()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ginkgo&amp;Gomega</title>
    <link href="/2021/08/09/Ginkgo&amp;Gomega/"/>
    <url>/2021/08/09/Ginkgo&amp;Gomega/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司项目实现标准化，打算给项目加上单元测试和集成测试，在Go的项目中由调研后打算采用<code>Ginkgo</code>和<code>Gomega</code>，看了下官方文档和github上的测试后写下点心得</p><p><code>Ginkgo</code>是Go语言的一个行为驱动开发(BDD)风格的<strong>测试框架</strong>，通常和Gomega一起使用</p><p><code>Gomega</code>是一个<strong>匹配/断言库</strong>，通常与Ginkgo测试框架搭配使用</p><p><a href="https://ke-chain.github.io/ginkgodoc/">Ginkgo官方中文文档</a></p><p><a href="https://onsi.github.io/gomega/">Gomega官方文档</a></p><p><a href="https://blog.gmem.cc/ginkgo-study-note">Ginkgo使用笔记</a></p><p>下面的文章对上面的文档进行了参考和引用</p><p>对于测试的方法和使用请参考具体的文档，本文章主要介绍实战的使用</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装Ginkgo</p><figure class="highlight vim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/onsi/ginkgo/ginkgo<br></code></pre></td></tr></table></figure><p>安装Gomega</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/onsi/gomega/...<br></code></pre></td></tr></table></figure><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p><code>Ginkgo</code>与Go自带测试挂钩，允许使用<code>go test</code>运行<code>Ginkgo</code>套件</p><blockquote><p>创建套件</p></blockquote><p>如果要为一个包编写<code>Ginkgo</code>测试，首先需要使用命令创建套件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> pkg/book <span class="hljs-comment">#假设要为book包编写测试</span><br>ginkgo bootstrap<br></code></pre></td></tr></table></figure><p>上诉命令会生成文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> books_test<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-comment">// 使用点号导入，把这两个包导入到当前命名空间</span><br>    . <span class="hljs-string">&quot;github.com/onsi/ginkgo&quot;</span><br>    . <span class="hljs-string">&quot;github.com/onsi/gomega&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestBooks</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// 将Ginkgo的Fail函数传递给Gomega，Fail函数用于标记测试失败，这是Ginkgo和Gomega唯一的交互点</span><br>    <span class="hljs-comment">// 如果Gomega断言失败，就会调用Fail进行处理</span><br>    RegisterFailHandler(Fail)<br> <br>    <span class="hljs-comment">// 启动测试套件</span><br>    RunSpecs(t, <span class="hljs-string">&quot;Books Suite&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>创建完成后就可以在当前包下使用<code>ginkgo</code>或者<code>go test</code>执行测试套件</p><p>​    </p><blockquote><p>添加Spec</p></blockquote><p>上面的空测试套件没有什么价值，我们需要在此套接下编写测试（Spec）。虽然可以在<code>books_suite_test.go</code>中编写测试，但是推荐分离到独立的文件中，特别是包中有多个需要被测试的源文件的情况下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ginkgo generate book #执行该命令可以生成源文件为book.go的测试<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ = Describe(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><code>Describe</code>块用来组织<code>Specs</code>，其中可以包含任意数量的</li><li><code>It</code>：可以在<code>Describe</code>、<code>Context</code>这两种容器块内编写<code>Spec</code>，每个<code>Spec</code>写在<code>It</code>块中；为了贴合自然语言，可以使用<code>It</code>的别名<code>Specify</code></li><li>使用<code>Describe</code>和<code>Context</code>来标识组织代码的具体行为</li><li><code>BeforeEach</code>：在<code>Spec</code>（It块）运行之前执行，嵌套<code>Describe</code>时最外层<code>BeforeEach</code>先执行</li><li><code>AfterEach</code>：在<code>Spec</code>运行之后执行，嵌套<code>Describe</code>时最内层<code>AfterEach</code>先执行</li><li><code>JustBeforeEach</code>：在<code>It</code>块，所有<code>BeforeEach</code>之后执行，在<code>It</code>之前运行</li></ul><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>现在要对网页后端的多个API接口进行集成测试</p><blockquote><p>初步</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ = Describe(<span class="hljs-string">&quot;Endpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>reqJSON <span class="hljs-keyword">string</span><br>res     *http.Response<br>req     *http.Request<br>client  *http.Client<br>url     <span class="hljs-keyword">string</span><br>method  <span class="hljs-keyword">string</span><br>err     error<br>)<br><br>BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>client = &amp;http.Client&#123;&#125;<br>res = &amp;http.Response&#123;&#125;<br>req = &amp;http.Request&#123;&#125;<br>&#125;)<br><br>Context(<span class="hljs-string">&quot;test test1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>url = <span class="hljs-string">&quot;http://127.0.0.1:8080/test1&quot;</span><br>method = <span class="hljs-string">&quot;GET&quot;</span><br>req, err = http.NewRequest(method, url, strings.NewReader(reqJSON))<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br><br>req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br><br>res, err = client.Do(req)<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>&#125;)<br><span class="hljs-comment">//直接对比res的status_code，简便</span><br>It(<span class="hljs-string">&quot;test1 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>gomega.Expect(res.StatusCode).Should(gomega.Equal(http.StatusOK))<br>&#125;)<br><br>&#125;)<br><br>Context(<span class="hljs-string">&quot;test test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>url = <span class="hljs-string">&quot;http://127.0.0.1:8080/test2/1&quot;</span><br>method = <span class="hljs-string">&quot;GET&quot;</span><br>req, err = http.NewRequest(method, url, strings.NewReader(reqJSON))<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br><br>req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br><br>res, err = client.Do(req)<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>&#125;)<br><span class="hljs-comment">//实现接口后可以自定义匹配规则，匹配方式灵活，并且可以打印自定义错误消息</span><br>It(<span class="hljs-string">&quot;test2 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>gomega.Expect(res).To(test.RepresentJSONObject(http.StatusOK))<br>&#125;)<br><br>&#125;)<br><br>Context(<span class="hljs-string">&quot;test test3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>url = <span class="hljs-string">&quot;http://127.0.0.1:8080/test3/1&quot;</span><br>method = <span class="hljs-string">&quot;PUT&quot;</span><br>reqJSON = <span class="hljs-string">&quot;&#123;\&quot;id\&quot;:1&#125;&quot;</span><br>req, err = http.NewRequest(method, url, strings.NewReader(reqJSON))<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br><br>req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>req.Header.Add(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br><br>res, err = client.Do(req)<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>&#125;)<br><span class="hljs-comment">//通过自定义匹配规则返回的err判定</span><br>It(<span class="hljs-string">&quot;test3 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>_, err := test.RepresentJSONObject(http.StatusOK).Match(res)<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>&#125;)<br><span class="hljs-comment">//通过自定义匹配规则返回的true判定，只答应ture和false的消息</span><br>It(<span class="hljs-string">&quot;test3 no err&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>gomega.Expect(test.RepresentJSONObject(http.StatusOK).Match(res)).Should(gomega.Equal(<span class="hljs-literal">true</span>))<br>&#125;)<br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>上诉的思想就是<strong>每个测试组件都提前定义好<code>request</code>和<code>response</code>，通过发送给<code>client</code>的<code>request</code>加上<code>Gomega</code>断言收到的response来进行测试</strong></li><li>把每个测试组件都要使用的变脸，如<code>url、method、client</code>等放最初的全局变量</li><li>每次使用前都要重新初始化<code>client</code>、<code>request</code>、<code>response</code>则放入<code>BeforeEach</code>（如果使用了<code>response.Body</code>）可以使用<code>AfterEach</code>进行关闭</li></ul><p>​    </p><p><strong>对上面不同的Gomega断言类型进行说明</strong></p><ul><li><p><code>gomega.Expect(res.StatusCode).Should(gomega.Equal(http.StatusOK))</code></p><p><code>Should</code>和<code>To</code>相同，表示肯定，<code>gomega.Equal</code>则是表示断言相等，连起来就是我们实际得到的<code>res.StatusCode</code>应该和<code>http.StatusOK</code>相同，相同测试成功，不同测试失败</p></li><li><p><code>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())</code></p><p><code>ShouldNot</code>和<code>NotTo</code>相同，表示否定，<code>gomega.HaveOccurred()</code>指示<code>non-nill</code>的<code>error</code>则成功，连起来就是如果出现<code>non-nil</code>的<code>error</code>就测试失败，<code>error</code>为<code>nil</code>则测试成功，则是<strong>非常典型的Go错误测试模式</strong></p></li><li><p><code>gomega.Expect(res).To(test.RepresentJSONObject(http.StatusOK))</code></p><p>自定义匹配规则，只要<strong>实现<code>Match</code>、<code>FailureMessage</code>、<code>NegatedFailureMessage</code>方法的接口</strong>就行，好处就是<strong>匹配规则灵活多变</strong>(传入的http.StatusOK作为expected去Match Expect中的 res)，匹配结果返回的是<code>false</code>和<code>non-err</code>则为测试失败</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RepresentJSONObject</span><span class="hljs-params">(expected <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">types</span>.<span class="hljs-title">GomegaMatcher</span></span> &#123;<br>   <span class="hljs-keyword">return</span> &amp;representJSONMatcher&#123;<br>      expected: expected,<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> representJSONMatcher <span class="hljs-keyword">struct</span> &#123;<br>   expected <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(matcher *representJSONMatcher)</span> <span class="hljs-title">Match</span><span class="hljs-params">(actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(success <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br>   response, ok := actual.(*http.Response)<br>   <span class="hljs-keyword">if</span> !ok &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">&quot;RepresentJSONObject matcher expects an http.Response&quot;</span>)<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> !reflect.DeepEqual(matcher.expected.(<span class="hljs-keyword">int</span>), response.StatusCode) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">&quot;actual and expect no equal ,expect is %d,actual is %d&quot;</span>, matcher.expected.(<span class="hljs-keyword">int</span>), response.StatusCode)<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(matcher *representJSONMatcher)</span> <span class="hljs-title">FailureMessage</span><span class="hljs-params">(actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(message <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Expected\n\t%#v\nto contain the JSON representation of\n\t%#v&quot;</span>, actual, matcher.expected)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(matcher *representJSONMatcher)</span> <span class="hljs-title">NegatedFailureMessage</span><span class="hljs-params">(actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(message <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Expected\n\t%#v\nnot to contain the JSON representation of\n\t%#v&quot;</span>, actual, matcher.expected)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>改进</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ = Describe(<span class="hljs-string">&quot;Endpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>   JustAfterEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      warpper.InitTCli()<br>   &#125;)<br><br>   Context(<span class="hljs-string">&quot;test test1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         err := warpper.TCli.Do(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/test1&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>         gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>      &#125;)<br><br>      It(<span class="hljs-string">&quot;test1 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         gomega.Expect(warpper.TCli.Res).To(warpper.RepresentJSONObject(http.StatusOK))<br>      &#125;)<br><br>   &#125;)<br><br>   Context(<span class="hljs-string">&quot;test test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         err := warpper.TCli.Do(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/test/1&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>         gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>      &#125;)<br><br>      It(<span class="hljs-string">&quot;test2 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         gomega.Expect(warpper.TCli.Res).To(warpper.RepresentJSONObject(http.StatusOK))<br>      &#125;)<br><br>   &#125;)<br><br>   Context(<span class="hljs-string">&quot;update endpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         reqJSON := <span class="hljs-string">&quot;&#123;\&quot;id\&quot;:1&#125;&quot;</span><br>         err := warpper.TCli.Do(<span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;/test3/1&quot;</span>, reqJSON)<br>         gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>      &#125;)<br>      It(<span class="hljs-string">&quot;update endpoint success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         gomega.Expect(warpper.TCli.Res).To(warpper.RepresentJSONObject(http.StatusOK))<br>      &#125;)<br>   &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TeClient <span class="hljs-keyword">struct</span> &#123;<br>   Res    *http.Response<br>   Req    *http.Request<br>   Client *http.Client<br>   Err    error<br>&#125;<br><br><span class="hljs-keyword">var</span> TCli *TeClient<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitTCli</span><span class="hljs-params">()</span></span> &#123;<br>   TCli = &amp;TeClient&#123;<br>      Res:    &amp;http.Response&#123;&#125;,<br>      Req:    &amp;http.Request&#123;&#125;,<br>      Client: &amp;http.Client&#123;&#125;,<br>      Err:    <span class="hljs-literal">nil</span>,<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>采用自定义封装匹配规则和<code>gomega.HaveOccurred()</code>错误断言</p></li><li><p>对变量定义和初始化进行封装，因为每次在调用后都要重新初始化<code>TCli</code>，所以采用创建套件时初始化<code>TCli</code>和每次<code>It</code>结束后初始化的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//在ginkgo bootstrap创建套件的文件中，表示启动测试套件的每一个总Describe运行前都要执行的代码</span><br><span class="hljs-keyword">var</span> _ = BeforeSuite(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>   warpper.InitTCli()<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>对<code>BeforeEach</code>中<code>client</code>发送<code>request</code>和接收<code>response</code>的代码进行封装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TeClient)</span> <span class="hljs-title">Do</span><span class="hljs-params">(method, url, reqJson <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>   adr := <span class="hljs-string">&quot;http://&quot;</span> + ip + url<br>   t.Req, t.Err = http.NewRequest(method, adr, strings.NewReader(reqJson))<br>   t.Req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>   t.Req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>   <span class="hljs-keyword">if</span> reqJson != <span class="hljs-string">&quot;&quot;</span> &#123;<br>      t.Req.Header.Add(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>   &#125;<br><br>   t.Res, t.Err = t.Client.Do(t.Req)<br>   <span class="hljs-keyword">if</span> t.Err != <span class="hljs-literal">nil</span> &#123;<br>      err := t.Err<br>      <span class="hljs-keyword">return</span> err<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>把测试组件相同的代码抽出成函数调用的方式，这样测试组件中的代码简介明了</p></li><li><p><code>Header.Add(“xxx”,&quot;xxx&quot;)</code>一般都是<code>token</code>、安全验证，因为在测试中使用的身份是一样的</p></li><li><p>对于有传如<code>request.Body</code>的<code>POST</code>方法才加<code>Header.Add(&quot;Content-Type&quot;, &quot;application/json&quot;)</code>，<code>GET</code>中不需要传入<code>request.Body</code>就不需要了</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go切片在函数中的传递</title>
    <link href="/2021/07/29/Go%E5%88%87%E7%89%87%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/"/>
    <url>/2021/07/29/Go%E5%88%87%E7%89%87%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在优化之前实习生的代码，在做<code>control</code>层和<code>db</code>层之间参数传递的时候，老师提出了切片就是引用类型，那么在使用数据库<code>Find</code>功能时只需要传<code>model</code>切片即可，就不需要传切片指针了，但是自己在实验的时候发现直接传切片时无法获取值的，只有传切片指针才行</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//传切片</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArticles</span><span class="hljs-params">(articles []model.Article)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> db.GetMysqlDB().Order(<span class="hljs-string">&quot;id desc&quot;</span>).Find(&amp;articles).Error<br>&#125;<br><span class="hljs-comment">//传切片指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArticles</span><span class="hljs-params">(articles *[]model.Article)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> db.GetMysqlDB().Order(<span class="hljs-string">&quot;id desc&quot;</span>).Find(&amp;articles).Error<br>&#125;<br></code></pre></td></tr></table></figure><p>后对此情况对网上的参考资料引用了大部分，做了少许修改的标注</p><p><a href="https://blog.csdn.net/LYue123/article/details/88363685?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.base">引用参考相关文章</a></p><h1 id="slice的参数"><a href="#slice的参数" class="headerlink" title="slice的参数"></a>slice的参数</h1><p>切片和数组是不一样的，数组是值类型，切片时引用类型，则我们相信在函数中传递地址切片，函数中改变，会直接影响到函数外与之对应的切片，现在做一个实验验证下想法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>   SliceTest1(s)<br>   fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest1</span><span class="hljs-params">(num []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> num != <span class="hljs-literal">nil</span> &amp;&amp; <span class="hljs-built_in">len</span>(num) &gt;= <span class="hljs-number">1</span> &#123;<br>      num[<span class="hljs-number">0</span>]=<span class="hljs-number">666</span><br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">//[666 2 3]</span><br></code></pre></td></tr></table></figure><p>​    </p><p>上面的代码结果验证了我们的想法，但是在函数中打印切片的地址，则会发现<strong>和函数外对应的切片地址不一样</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   num := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>   fmt.Printf(<span class="hljs-string">&quot;main addr is %p\n&quot;</span>,&amp;num)<br>   SliceTest1(num)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest1</span><span class="hljs-params">(num []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;function slice addr is %p\n&quot;</span>,&amp;num)<br>   <span class="hljs-keyword">if</span> num != <span class="hljs-literal">nil</span> &amp;&amp; <span class="hljs-built_in">len</span>(num) &gt;= <span class="hljs-number">1</span> &#123;<br>      num[<span class="hljs-number">0</span>]=<span class="hljs-number">666</span><br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">//main addr is 0xc0000044a0</span><br><span class="hljs-comment">//function slice addr is 0xc0000044e0</span><br></code></pre></td></tr></table></figure><p>此时我们需要先了解下slice的实现</p><h1 id="Slice的实现"><a href="#Slice的实现" class="headerlink" title="Slice的实现"></a>Slice的实现</h1><p>切片不等同于数组，但他依赖数组实现的，切片是一种复合结构，它由三部分组成的，第一部分是底层数组的指针<code>ptr</code>，第二部分是切片大小<code>len</code>，最后是切片容量<code>cap</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest2</span><span class="hljs-params">()</span></span> &#123;<br>   num := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>   slice := num[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br>   slice2 := num[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>   fmt.Printf(<span class="hljs-string">&quot;slice: %v,slice addr %p\n&quot;</span>, slice, &amp;slice)<br>   fmt.Printf(<span class="hljs-string">&quot;slice: %v,slice addr %p\n&quot;</span>, slice2, &amp;slice2)<br>   num[<span class="hljs-number">2</span>] = <span class="hljs-number">11</span><br>   fmt.Printf(<span class="hljs-string">&quot;slice: %v,slice addr %p\n&quot;</span>, slice, &amp;slice)<br>   fmt.Printf(<span class="hljs-string">&quot;slice: %v,slice addr %p&quot;</span>, slice2, &amp;slice2)<br>&#125;<br><span class="hljs-comment">//slice: [2 3 4],slice addr 0xc0000044a0</span><br><span class="hljs-comment">//slice: [3 4 5],slice addr 0xc0000044c0</span><br><span class="hljs-comment">//slice: [2 11 4],slice addr 0xc0000044a0</span><br><span class="hljs-comment">//slice: [11 4 5],slice addr 0xc0000044c0</span><br></code></pre></td></tr></table></figure><ul><li>我们看这个例子，有一个5个元素的数组，slice，slice2分别截取了数组的一部分，并且有共同的一部分，我们现在能明确的就是，<strong>两个切片共用一个数组</strong>，所以一个改变都改变，还有就是<strong>两个数组是两个不同的对象，很明显内存地址不同</strong></li><li>从数组中切一块下来形成切片很好理解，有时候我们用make函数创建切片，实际上golang会在底层创建一个匿名的数组。如果从新的slice再切，那么<strong>新创建的两个切片都共享这个底层的匿名数组</strong></li></ul><h1 id="作为函数切片的参数"><a href="#作为函数切片的参数" class="headerlink" title="作为函数切片的参数"></a>作为函数切片的参数</h1><p>回到最开始的问题，当函数的参数是切片的时候，到底是传值还是传引用？从changeSlice函数中打出的参数s的地址，可以看出肯定不是传引用，毕竟引用都是一个地址才对。然而changeSlice函数内改变了s的值，也改变了原始变量slice的值，这个看起来像引用的现象，实际上正是我们前面讨论的切片共享底层数组的实现</p><p><strong>即切片传递的时候，传的是数组的值</strong>，等效于从原始切片中再切了一次。<strong>原始切片slice和参数s切片的底层数组是一样的</strong>。因此修改函数内的切片，也就修改了数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   num := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>   SliceTest3(num)<br>   fmt.Println(num)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest3</span><span class="hljs-params">(num []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>num = <span class="hljs-built_in">append</span>(num, <span class="hljs-number">2</span>)<br>fmt.Println(num)<br>&#125;<br><span class="hljs-comment">//[0 1 2]</span><br><span class="hljs-comment">//[0 1]</span><br></code></pre></td></tr></table></figure><p>Slice或者array作为函数参数传递的时候，<strong>本质是传值而不是传引用</strong>。传值的过程复制一个新的切片，这个切片也指向原始变量的底层数组。（个人感觉称之为传切片可能比传值的表述更准确）。函数中无论是直接修改切片，还是append创建新的切片，都是基于共享切片底层数组的情况作为基础。也就是最外面的原始切片是否改变，取决于函数内的操作和切片本身容量</p><p>​    </p><p><strong>如果想要传引用的时候怎么办的，则传地址即可</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   num := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>   SliceTest4(&amp;num)<br>   fmt.Println(num)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest4</span><span class="hljs-params">(num *[]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   *num = <span class="hljs-built_in">append</span>(*num, <span class="hljs-number">2</span>)<br>   fmt.Println(*num)<br>&#125;<br><span class="hljs-comment">//[0 1 2]</span><br><span class="hljs-comment">//[0 1 2]</span><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>golang提供了array和slice两种序列结构。其中array是值类型。<strong>slice则是复合类型</strong>。slice是基于array实现的。slice的第一个内容为指向数组的指针，然后是其长度和容量。通过array的切片可以切出slice，也可以使用make创建slice，此时golang会生成一个匿名的数组</p><p>因为slice依赖其底层的array，修改slice本质是修改array，而array又是有大小限制，当超过slice的容量，即数组越界的时候，需要通过动态规划的方式创建一个新的数组块。把原有的数据复制到新数组<strong>，这个新的array则为slice新的底层依赖</strong></p><p>数组还是切片，在函数中传递的不是引用，是另外一种值类型，即通过原始变量进行切片传入。函数内的操作即对切片的修改操作了。当然，<strong>如果为了修改原始变量，可以指定参数的类型为指针类型</strong>。传递的就是slice的内存地址。函数内的操作都是根据内存地址找到变量本身</p><p>​    </p><p><strong>则在最开始db层操作中，因为传入的肯定是空的model切片，在查找时必定会发生扩容，则此时就需要传入切片指针才行</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GORM v2的使用</title>
    <link href="/2021/07/21/Gorm_v2/"/>
    <url>/2021/07/21/Gorm_v2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一直使用的是<code>Gorm</code>的v1，有些地方也觉得不方便，正好今天需要在原生sql语句后用count计数功能，则看了<code>Gorm</code>版本v2的更新，发现有很多新的玩法，就记录下自己工作中遇到的情况</p><p><a href="https://gorm.io/zh_CN/docs/index.html">Gorm官方文档</a></p><p><a href="https://learnku.com/docs/gorm/v2/connecting_to_the_database/9731">Gorm文档</a></p><h1 id="安装Gorm-v2"><a href="#安装Gorm-v2" class="headerlink" title="安装Gorm v2"></a>安装Gorm v2</h1><p>GORM 官方支持的数据库类型有： <code>MySQL</code>, <code>PostgreSQL</code>, <code>SQlite</code>, <code>SQL Server</code></p><figure class="highlight maxima"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">go</span> <span class="hljs-built_in">get</span> -u gorm.io/gorm<br><span class="hljs-built_in">go</span> <span class="hljs-built_in">get</span> -u gorm.io/driver/sqlite<br></code></pre></td></tr></table></figure><p>如果安装<code>sqlite</code>可能会报错</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">exec</span>: <span class="hljs-string">&quot;gcc&quot;</span>: executable <span class="hljs-keyword">file</span> not found <span class="hljs-keyword">in</span> %PATH%<br></code></pre></td></tr></table></figure><p>原因是<code>sqlite 3</code>是个<code>cgo</code>库，需要<code>gcd</code>编译c代码，需要安装<code>mingw</code></p><p><strong>解决方法</strong></p><ul><li><p><a href="https://sourceforge.net/projects/mingw-w64/files/?source=navbar">下载mingw安装包</a></p></li><li><p>解压后将bin路径加入环境变量</p></li><li><p>终端中输入<code> gcc --version</code>有相关信息则说明安装成功</p></li></ul><p>添加后如果<strong>还是运行失败</strong>，就是环境变量更改未生效，<strong>重启电脑</strong>就可以了</p><h1 id="安装Msyql驱动并使用"><a href="#安装Msyql驱动并使用" class="headerlink" title="安装Msyql驱动并使用"></a>安装Msyql驱动并使用</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get gorm.io<span class="hljs-regexp">/driver/my</span>sql<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  dsn := <span class="hljs-string">&quot;user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就比v1体验更好，v1中经常忘记引入驱动 <strong><code>import _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot;</code></strong></p><p>Mysql驱动程序提供了一些<strong>高级配置</strong>可以在初始化的时候使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">db, err := gorm.Open(mysql.New(mysql.Config&#123;<br>  DSN: <span class="hljs-string">&quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, <span class="hljs-comment">// DSN data source name</span><br>  DefaultStringSize: <span class="hljs-number">256</span>, <span class="hljs-comment">// string 类型字段的默认长度</span><br>  DisableDatetimePrecision: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持</span><br>  DontSupportRenameIndex: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引</span><br>  DontSupportRenameColumn: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列</span><br>  SkipInitializeWithVersion: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 根据当前 MySQL 版本自动配置</span><br>&#125;), &amp;gorm.Config&#123;&#125;)<br></code></pre></td></tr></table></figure><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><blockquote><p>原生sql语句</p></blockquote><p>通过db.Raw设置sql语句，通过Scan执行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">db.Raw(&quot;SELECT id, name, age FROM users WHERE id = ?&quot;, 3).Scan(&amp;result)<br></code></pre></td></tr></table></figure><p><strong>使用原生sql后的<code>Scan</code>不能跟<code>Count</code></strong></p><p><code>Exec</code> 原生 SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">db.Exec(&quot;UPDATE orders SET shipped_at=? WHERE id IN ?&quot;, time.Now(), []int64&#123;1,2,3&#125;)<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>raw后接count</p></blockquote><p>在GORM v1中使用原生sql语句<code>Raw</code>后不能接<code>Find</code>，只能<code>Scan</code>，并且<code>Scan</code>后不能使用计数<code>Count</code></p><p>在v2中<code>Scan</code>后可以接<code>Count</code>，并且<code>Raw</code>后也可以接<code>Find</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">DB.DB.Raw(<span class="hljs-string">&quot;select *from articles where user_id = ? &quot;</span>,u.ID).Find(&amp;articles).Count(&amp;count).Error<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">DB.DB.Raw(<span class="hljs-string">&quot;select *from articles where user_id = ? &quot;</span>,u.ID).Scan(&amp;articles).Count(&amp;count).Error<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>预加载</p></blockquote><p>GORM v2 允许在 <code>Preload</code> 的其它 SQL 中直接加载关系</p><p>例如：user中有card数组，使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Preload(<span class="hljs-string">&quot;Cards&quot;</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><p>就可以将相关card信息从cards数据表中也添加到users结构体中</p><p>​    </p><blockquote><p>命名参数</p></blockquote><p>GORM 支持 <code>sql.Named</code>、<code>map[string]interface&#123;&#125;&#123;&#125;</code> 的命名参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">DB.DB.Model(model.Article&#123;&#125;).Where(<span class="hljs-string">&quot;user_id=@id&quot;</span>, sql.Named(<span class="hljs-string">&quot;id&quot;</span>, u.ID)).Find(&amp;articles).Count(&amp;count).Error<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">DB.DB.Raw(<span class="hljs-string">&quot;select *from articles where user_id = @id &quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;id&quot;</span>:u.ID&#125;).Scan(&amp;articles).Error<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>GORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决github和gitlab多账户管理ssh冲突问题</title>
    <link href="/2021/07/19/git%E4%B8%8D%E5%90%8C%E4%BB%93%E5%BA%93ssh%E5%86%B2%E7%AA%81/"/>
    <url>/2021/07/19/git%E4%B8%8D%E5%90%8C%E4%BB%93%E5%BA%93ssh%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<p><strong>问题</strong>  </p><blockquote><p>解决github和gitlab多账户管理ssh冲突问题</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">git@gitlab.com: Permission denied<br>or<br>git@github.com: Permission denied<br></code></pre></td></tr></table></figure><p>本地邮箱是识别的唯一手段，在实际生活中采用同一个邮箱对不同仓库进行开发可能性不是很大，<strong>因为公司会给予新员工新的邮箱</strong>，而本地的ssh只会标记一个邮箱，则使用不同邮箱会冲突    </p><p>​    </p><p><strong>解决方法</strong>  </p><blockquote><p>基于config文件</p></blockquote><ul><li><p>进入 <code>/c/Users/user_name/.ssh</code> 也就是 <code>~/.ssh</code></p></li><li><p>将不同的ssh放入不同文件，生成密钥时选择对应文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh-keygen -t rsa -C 不同的邮箱 <br><span class="hljs-comment">#不指定文件名则在 ~/.ssh 目录默认生成</span><br>ssh-keygen -t rsa -f ~/.ssh/gitlabsshkey -C 不同的邮箱<br><span class="hljs-comment">#指定gitlab的ssh生成的目录位置</span><br></code></pre></td></tr></table></figure></li><li><p>设置配置文件（在 <code>~/.ssh/config</code>,没有就手动创建 <code>touch config</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host github.com  <br>    HostName github.com  <br>    PreferredAuthentications publickey  <br>    IdentityFile ~/.ssh/id_rsa  #这里是GitHub生成sshkey的那个文件路径<br><br>Host gitlab.com<br>    HostName xx.xx.xx #填写对应公司的仓库地址<br>    PreferredAuthentications publickey  <br>    IdentityFile ~/.ssh/gitlabsshkey/id_rsa  #这里是GitHub生成sshkey的那个文件路径<br></code></pre></td></tr></table></figure></li></ul><p>​    </p><p><strong>进行验证</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com #如果你用的是github<br><span class="hljs-meta">#</span><span class="bash">Hi xxx! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span> <br>ssh -T git@gitlab.com #如果你用的是gitlab<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string">Welcome to GitLab, xxx!</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新篇章</title>
    <link href="/2021/07/07/%E6%96%B0%E7%AF%87%E7%AB%A0/"/>
    <url>/2021/07/07/%E6%96%B0%E7%AF%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><p>很早前就想弄一个自己的博客了。但是因为各种原因 (主要还是自己懒) 就没有弄，平时自己也会通过typora写一点笔记，在后续也会慢慢整理发布</p></li><li><p>现在出来实习了，也顺便记录一下平时的工作心得和知识，欢迎大家纠正和讨论</p></li><li><p>取名为新的篇章也算是应景了，大三下出来实习也算是正式告别学生身份了，以打工人的身份拥抱社会，也不管前方要面对什么，冲冲冲就完事了</p></li><li><p>保持热情，保持激情！</p></li><li><p>扬帆  启航！</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
